classdef difftensor
    % DIFFTENSOR
    % "Diffusion tensor" class definition and operators
    % overloading/definition.
    %
    % D = difftensor(F)
    % A tensor object can be generated by passing F as
    % - a 3x3 (tensor) matrix
    % - a cell array of 3x3 (tensor) matrices or 6 cell arrays (one per
    %   component of the tensor) or N-D matrices.
    % - a 4D/3D/2D array (Nx x Ny x Nz x 6) with tensor's 6 components 
    %     (xx, xy,xz, yy, yz, zz)
    %
    % Options:
    % - when passing 6 components, the default order is [Dxx Dxy Dxz Dyy 
    %   Dyz Dzz] but an extra array argument can be passed to reorder these
    %   commonents. 
    %   E.g order = [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz] and
    %   D = difftensor(F,order)
    % - you can force to take the absolute value of the eigenvalues of the
    %   3x3 passed (or created from the 6 components) to ensure it is
    %   positive demi-definite, by passing an extra char argument 'abs'.
    %   E.g. D = difftensor(F,'abs') or D = difftensor(F,order,'abs')
    %
    % Each tensor is defined internally only by its:
    %   - eigenvalues (EigValues), sorted in descending order
    %   - orientation (Orientation), expressed as a quaternion
    %   - eigenvectors (EigVectors), this is redundant but efficient for
    %       logE calculation
    % Tensor can be organised in arrays of "any" size.
    %
    % METHODS:
    %   difftensor    - building of the tensor (array)
    %   getDet        - get determinant(s)
    %   getFA         - get the FA value(s)
    %   getRA         - get the RA value(s)
    %   getHA         - get the HA value(s)
    %   getTensor     - get the tensor(s)
    %   getTr         - get the trace(s)
    %   get1stEV      - get the 1st eigenvector (main direction)
    %   dist          - distance between 2 tensors, with SQ or LogE metric
    %   wmean         - weighter mean of all array
    %   mean          - mean of tensors, column-wise
    %   std           - standard deviation of distance around mean tensor
    %   rotate        - rotate tensor(s)
    %   rotate_q      - rotate tensor(s) - quaternion representation
    %   scale         - rescale tensor(s)
    %   text_display  - display as text
    %   graph_display - display graphically (up to 3D arrays)as ellipses
    %   vect_display  - display the main vector, weighted by the FA
    %   isempty       - overloaded function for difftensor
    %
    % More information about the SQ methods (distance, mean) are available
    % in 
    % 'A. Collard, S.Bonnabel, C. Phillips and R. Sepulchre, 'Anisotropy
    % preserving DTI processing', International Journal of Computer
    % Vision, 2014, 107:58-74.
	% http://link.springer.com/article/10.1007/s11263-013-0674-4
    % 
    %______________________________________________________________________
    % Copyright (C) 2014 University of Liege, Belgium
    
    % Written by A. Collard & C. Phillips, 2014.
    % Department of Electrical Engineering and Computer Science &
    % Cyclotron Research Centre, University of Liege, Belgium
    % Contact: c.phillips@ulg.ac.be

    %% PROPERTIES
    properties
        EigValues   % eigenvalues, sorted in descending order
        Orientation % eigenvectors expressed as a quaternion
        EigVectors  % eigenvectors (this is redundant but more efficient
                    % for logE calculation)
    end
    
    properties (SetAccess = private)
        HA
        setQ
    end
    
    methods
        %% OBJECT DEFINITION: set tensor, eigenvalues & orientation
        function d = difftensor(F,varargin)
            % Allow nargin == 0 syntax
            if nargin ~= 0 && iscell(F)
                if ndims(F)==2 && length(F)==6 %#ok<*ISMAT>
                    % Input as 6 cell arrays with the 6 tensor elements
                    
                    % Handle special cases: different ordering of
                    % components and taking the abs-value of eigen values.
                    if nargin==1
                        order = [1 2 3 4 5 6];
                        % for [Dxx Dxy Dxz Dyy Dyz Dzz] by default
                        aEigVal = false;
                    elseif nargin==2
                        if isnumeric(varargin{1})
                            order = varargin{1};
                            % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                            if numel(order)~=6
                                warning('difftensor:order', ...
                                    '[difftensor] Wrong ''order'' size, using default.'); %#ok<*WNTAG>
                                order = [1 2 3 4 5 6];
                            end
                            aEigVal = false;
                        elseif ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                            order = [1 2 3 4 5 6];
                        else
                            error('[difftensor] Wrong input to create tensor (array).');
                        end
                    elseif nargin==3
                        order = varargin{1};
                        % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                        if numel(order)~=6
                            warning('difftensor:order', ...
                                '[difftensor] Wrong ''order'' size, using default.');
                            order = [1 2 3 4 5 6];
                        end
                        if strcmpi(varargin{2},'abs')
                            aEigVal = true;
                        else
                            aEigVal = false;
                        end
                    else
                        error('[difftensor] Wrong input to create tensor (array).');
                    end
                    
                    % Build tensor array
                    sz = size(F{1});
                    d(prod(sz)) = difftensor; % Preallocate object array
                    for ii = 1:prod(sz)
                        tmp = [ ...
                            F{order(1)}(ii) F{order(2)}(ii) F{order(3)}(ii) ; ...
                            F{order(2)}(ii) F{order(4)}(ii) F{order(5)}(ii) ; ...
                            F{order(3)}(ii) F{order(5)}(ii) F{order(6)}(ii) ];
                        d(ii) = difftensor(tmp,aEigVal);
                    end
                    d = reshape(d,sz);
                else
                    % Input as cell array, each cell being a 3x3 array
                    if nargin==1
                        aEigVal = false;
                    elseif nargin==2
                        if ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                        
                        else
                            error('[difftensor] Wrong input to create tensor (array).');
                        end
                    end
                    sz = size(F); % allow any cell-array size
                    d(prod(sz)) = difftensor; % Preallocate object array
                    for ii = 1:prod(sz)
                        d(ii) = difftensor(F{ii},aEigVal);
                    end
                    d = reshape(d,sz);
                end
                
            elseif nargin ~=0 && ~iscell(F)
                % Input as numerical array in various format
                if ~isnumeric(F)
                    error('[difftensor] The diffusion tensor must be a 3x3 matrix.');
                end
                if ndims(F)==2 && all(size(F)==[3 3])
                    % 3x3 array
                    % Take the absolute value of eigenvalues, or not?
                    if nargin==1
                        aEigVal = false;
                    else
                        aEigVal = logical(varargin{1});
                    end
                    % Build tensor
                    [V,E] = eig(F);
                    if aEigVal, E = abs(E); end
                    if sum(sign(diag(E)))<3
                        warning('difftensor:eigval', ...
                            '[difftensor] The diffusion tensor must be positive.');
                        d = difftensor; % returning empty tensor
                        return
                    end
                    d.EigValues = diag(E);
                    V = det(V)*V;
                    [~, I] = sort(diag(E),'descend');
                    V1 = [V(:,I(1)) V(:,I(2)) V(:,I(3))];
                    V1 = V1*det(V1);
                    q1 = mat2quat(V1);
                    d.EigVectors = V1;
                    d.Orientation = q1;
                    d.HA = calcHA(d.EigValues);
                    d.setQ = getSetQ(q1);
                elseif  (ndims(F)==4 && size(F,4)==6) || ...
                        (ndims(F)==3 && size(F,3)==6) || ...
                        (ndims(F)==2 && length(F)==6)
                    % 4D/3D/2D array Nx (x Ny) (x Nz) x 6 array,
                    % as in 3D/2D/1D x 6 images
                    % The last dimension should always be of size 6!
                    
                    % Handle special cases: 
                    %   - different ordering of components and,
                    %   - taking the abs-value of eigen values or not.
                    if nargin==1
                        order = [1 2 3 4 5 6];
                        % for [Dxx Dxy Dxz Dyy Dyz Dzz] by default
                        aEigVal = false;
                    elseif nargin==2
                        if isnumeric(varargin{1})
                            order = varargin{1};
                            % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                            if numel(order)~=6
                                warning('difftensor:order',...
                                    '[difftensor] Wrong ''order'' size, using default.');
                                order = [1 2 3 4 5 6];
                            end
                            aEigVal = false;
                        elseif ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                            order = [1 2 3 4 5 6];
                        else
                            error('[difftensor] Wrong input to create tensor (array).');
                        end
                    elseif nargin==3
                        order = varargin{1};
                        % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                        if numel(order)~=6
                            warning('difftensor:order', ...
                                '[difftensor] Wrong ''order'' size, using default.');
                            order = [1 2 3 4 5 6];
                        end
                        if strcmpi(varargin{2},'abs')
                            aEigVal = true;
                        else
                            aEigVal = false;
                        end
                    else
                        error('[difftensor] Wrong input to create tensor (array).');
                    end
                    
                    sz = size(F);
                    % Special case of 6 elements as a 6x1 vector
                    if ndims(F)==2 && sz(1)==6 && sz(2)==1
                        F = F';
                        sz = size(F);
                    end
                    
                    % Create tensor array
                    F = reshape(F,prod(sz(1:end-1)),6)';
                    d(prod(sz(1:end-1))) = difftensor; % allocate object array
                    for ii = 1:prod(sz(1:end-1))
                        tF = F(order,ii);
                        tmp = [ tF(1) tF(2) tF(3) ; ...
                                tF(2) tF(4) tF(5) ; ...
                                tF(3) tF(5) tF(6) ];
                        d(ii) = difftensor(tmp,aEigVal);
%                         if sum(tF([1 4 6]))>0
%                             tmp = [ tF(1) tF(2) tF(3) ; ...
%                                 tF(2) tF(4) tF(5) ; ...
%                                 tF(3) tF(5) tF(6) ];
%                             d(ii) = difftensor(tmp);
%                         else
%                             % dealing with case of voxel with zero's
%                             d(ii) = difftensor;
%                         end
                    end
                    if length(sz)>2 % 3D/2D array only
                        d = reshape(d,sz(1:end-1));
                    end
                else
                    error('[difftensor] Unknown input format.');
                end
            end
        end
        
        function obj = set.EigValues(obj,value)
            % Eigenvalues are sorted in descending order.
            % Their positiveness is checked!
            if sum(sign(value))<3 || numel(value)~=3
                display(value);
                error('difftensor:eigval', ...
                    '[difftensor] The diffusion tensor must be positive.');
            end
            value = sort(value,'descend');
            obj.EigValues = value(:);
        end
        
        function obj = set.Orientation(obj,value)
            % The dimension and norm of the quaternion are checked.
            if abs(norm(value)-1)>10e-5 || numel(value)~=4
                error('difftensor:quaternion', ...
                    '[difftensor] Orientation must be given by a unit quaternion.');
            end
            obj.Orientation = value(:);
        end
        
        function obj = set.EigVectors(obj,value)
            % The dimension and norm of the rotation matrix are checked.
            if numel(value)==4 && abs(norm(value)-1)<10e-5
                value = quat2mat(value);
            end
            if abs(det(value)-1)>10e-5 || numel(value)~=9
                error('difftensor:eigvect', ...
                    '[difftensor] Eigenvectors must be given by a rotation matrix.');
            end
            obj.EigVectors = value(:,:);
        end
        
        function obj = set.HA(obj,value)
            % HA set method
            obj.HA = value;
        end
        
        function obj = set.setQ(obj,value)
            % setQ set method
            if numel(value)==4
                obj.setQ= getSetQ(value);
            else
                obj.setQ = value;
            end
        end
        
        %% OBJECT METHODS: overloading some simple functions
        %%
        
        function out = isempty(obj)
            % check for empty tensor
            sz = size(obj);
            out = zeros(sz);
            for ii=1:prod(sz)
                out(ii) = isempty(obj(ii).EigValues);
            end
        end
        
        %% OBJECT METHODS: get tensor, determinant, trace, RA, FA,
        %%                 1st EigVector, max EigValues, min EigValues
        %%
        
        function T = getTensor(obj,opt)
            % get the (rebuilt) tensors
            if nargin<2, opt = 'cll'; end
            sz = size(obj);
            if prod(sz)==1
                if ~isempty(obj)
                    R = quat2mat(obj.Orientation);
                    T = R*diag(obj.EigValues)*R';
                else
                    T = [];
                end
            else
                switch opt
                    case 'cll'
                        % Output as cell array of tensors
                        T = cell(sz);
                        for ii=1:prod(sz);
                            if ~isempty(obj(ii))
                                R = quat2mat(obj(ii).Orientation);
                                T{ii} = R*diag(obj(ii).EigValues)*R';
                            else
                                T{ii} = [];
                            end
                        end
                    case 'img'
                        % Output as 'image' component (sz x 6)
                        T = zeros(prod(sz),6);
                        for ii=1:prod(sz);
                            if ~isempty(obj(ii))
                                R = quat2mat(obj(ii).Orientation);
                                tmp = R*diag(obj(ii).EigValues)*R';
                                T(ii,:) = [tmp(1) tmp(2) tmp(3) ...
                                    tmp(5) tmp(6) tmp(9)];
                            end
                        end
                        T = reshape(T,[sz, 6]);
                end
            end
        end
        
        function EV1 = get1stEV(obj)
            % Get the 1st eigenvector
            sz = size(obj);
            EV1 = zeros([prod(sz),3]);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    EV1(ii,:) = obj(ii).EigVectors(:,1)';
                end
            end
            if prod(sz)>1
                EV1 = reshape(EV1,[sz 3]);
            else
                EV1 = EV1';
            end
        end
        
        function dete = getDet(obj)
            % Det get method
            sz = size(obj);
            dete = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    dete(ii) = prod(obj(ii).EigValues);
                end
            end
        end
        
        function tr = getTr(obj)
            % trace get method
            sz = size(obj);
            tr = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    tr(ii) = sum(obj(ii).EigValues);
                end
            end
        end
        
        function RA = getRA(obj)
            % RA get method
            sz = size(obj);
            RA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    RA(ii) = calcRA(obj(ii).EigValues);
                end
            end
        end
        
        function FA = getFA(obj)
            % FA get method
            sz = size(obj);
            FA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    FA(ii) = calcFA(obj(ii).EigValues);
                end
            end
        end
        
        function HA = getHA(obj)
            % HA get method
            sz = size(obj);
            HA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    HA(ii) = calcHA(obj(ii).EigValues);
                end
            end
        end
               
        %% OBJECT METHODS: apply rotation, affine & scale
        function dr = rotate(d,R)
            % Rotate d by R (3x3 matrix).
            % - if R is a single rot matrix -> apply on all elements of d
            % - if R is a cell-array of rot matrices and d has the same
            %   size as d -> apply rotation element by element
            
            dr = d;
            if iscell(R) && all(size(d)==size(R))
                % apply rotation element by element
                for ii=1:numel(d)
                    if all(size(R{ii})==[3 3]) && abs(det(R{ii})-1)>1e-10
                        error('[difftensor] R must be a rotation matrix');
                    end
                    qR = mat2quat(R{ii});
                    dr(ii) = rotate_q(d(ii),qR);
                end
            elseif isnumeric(R)
                % apply same rotation matrix to all tensors
                if all(size(R)==[3 3]) && abs(det(R)-1)>1e-10
                    display(R)
                    error('[difftensor] R must be a rotation matrix');
                end
                qR = mat2quat(R);
                dr = rotate_q(d,qR);
            else
                error('[difftensor] Invalid rotation operation.');
            end
        end
        
        function dr = rotate_q(d,qR)
            % Rotate d by qR (quaternion).
            % - if R is a single unit quaternion -> apply on all elements of d
            % - if R is a cell-array of quaternions and d has the same
            %   size as d -> apply rotation element by element
            
            dr = d;
            if iscell(qR) && all(size(d)==size(qR))
                % apply rotation element by element
                for ii=1:numel(d)
                    if all(size(qR{ii})==[4 1]) && abs(norm(qR{ii})-1)>1e-10
                        error('[difftensor] qR must be a cell of unit quaternions');
                    end
                    QR = [qR{ii} -qR{ii}];
                    qR_R = realignQ(d(ii).Orientation,QR);
                    qnew = multiplication(qR_R,d(ii).Orientation);
                    dr(ii).Orientation = qnew;
                    dr(ii).EigVectors = quat2mat(qnew);
                end
            elseif isnumeric(qR)
                % apply same rotation matrix to all tensors
                if all(size(qR)==[4 1]) && abs(norm(qR)-1)>1e-10
                    error('[difftensor] qR must be a unit quaternion');
                end
                QR = [qR -qR];
                for ii=1:numel(d)
                    qR_R = realignQ(d(ii).Orientation,QR);
                    qnew = multiplication(qR_R,d(ii).Orientation);
                    dr(ii).Orientation = qnew;
                    dr(ii).EigVectors = quat2mat(qnew);
                end
            else
                error('[difftensor] Invalid rotation operation.');
            end
        end
       
        function ds = scale(d,S)
            % Scale d by S
            % - if S is a cell-array of scaling (3x1) vectors and d is a
            %   difftensor array of the same size as S
            %       -> apply scaling eigenvalue by eigenvalue and element
            %          by element
            % - if S is a scalar-array of scaling factor and d is a
            %   diftensor array of the same size as S
            %       -> apply scaling on 3 eigenvalues element by element
            % - if S is a 3x1 vector
            %       -> all the scaling on each eigenvalues of all elements
            % - if S is a single scalar
            %       -> apply the same scaling to all eigenvalues
            % S{ii}/S can thus be
            % - a scalar -> scale all eigenvalues by S
            % - a 3x1 vector -> scale each eigenvalue by corresponding S_i
            
            ds = d;
            if iscell(S) && all(size(d)==size(S))
                % apply 3x1 scaling element by element
                for ii=1:numel(d)
                    if any(S{ii}<0) || numel(S{ii})~=3
                        error('[difftensor] Invalid scaling operation.');
                    end
                    if ~isempty(d(ii))
                        ds(ii).EigValues = S{ii}(:).*d(ii).EigValues;
                    end
                end
                
            elseif isnumeric(S)
                if any(S<=0)
                    error('[difftensor] Scaling must be positive.');
                end
                if all(size(d)==size(S))
                    % apply scaling element by element
                    for ii=1:numel(d)
                        if ~isempty(d(ii))
                            ds(ii).EigValues = S(ii)*d(ii).EigValues;
                        end
                    end
                elseif numel(S)==3 || numel(S)==1
                    % apply same scaling to all elements
                    for ii=1:numel(d)
                        if ~isempty(d(ii))
                            ds(ii).EigValues = S.*d(ii).EigValues;
                        end
                    end
                else
                    error('[difftensor] Invalid scaling operation.');
                end
            else
                error('[difftensor] Invalid scaling operation.');
            end
        end
        
        %% OBJECT METHODS: display functions (text & plot)
        function text_display(d)
            % Rebuild the tensor and 'print' it
            for ii=1:numel(d)
                display(getTensor(d(ii)));
            end
        end
        
        function vect_display(d)
            % vect_display(d)
            %
            % Plot the 1st eigenvector of the tensor as a small line:
            % - the length is proportional to FA
            % - color is the RGB of the 1st eigenvector
            sz = size(d);
            if numel(sz)>3,
                error('[difftensor] Can only display up to 3D tensor array');
            elseif numel(sz)==2
                sz(3) = 1;
            elseif numel(sz)==1
                sz(2) = 1; sz(3) = 1;
            end
            figure
            hold on
            for ii=1:sz(1)
                for jj=1:sz(2)
                    for kk=1:sz(3)
                        if ~isempty(d(ii,jj,kk))
                            v = d(ii,jj,kk).EigVectors(:,1);
                            vw = v*getFA(d(ii,jj,kk))/2;
                            x = (jj-1);
                            y = (ii-1);
                            z = (kk-1);
                            plot3([x+vw(1) x-vw(1)]',[y+vw(2) y-vw(2)]',...
                                [z+vw(3) z-vw(3)],'Color',abs(v)','LineWidth',2)
                            plot3(x,y,z,'ko')
                        end
                    end
                end
            end
            axis image
            axis xy
            light
            lighting gouraud
            view(3)
            rotate3d on
            xlabel('axis i'), ylabel('axis j'), zlabel('axis k')
        end
        
        function graph_display(d,s,typecol)
            % graph_display(d,s)
            %
            % Can plot single tensor or array of tensors, up to 3D, as
            % ellipsoids. These can be scaled by a scalar (s).
            
            if nargin<2,
                M_ev = maxEV(d);
                s = 1/sqrt(max(M_ev(:)));
                typecol = 'Dircol';
            elseif isempty(s)
                s = 1;
            elseif s<0
                M_ev = maxEV(d);
                s = -s*1/sqrt(max(M_ev(:)));
            elseif nargin<3
                typecol = 'Dircol';
            end
            
            n  = 20;
            xc = 0; yc = 0; zc = 0;
            sz = size(d);
            if numel(sz)>3,
                error('[difftensor] Can only display up to 3D tensor array');
            elseif numel(sz)==2
                sz(3) = 1;
            elseif numel(sz)==1
                sz(2) = 1; sz(3) = 1;
            end
            maxHA= max(max(getHA(d)));
            minHA= min(min(getHA(d)));
            figure
            hold on
            for ii=1:sz(1)
                for jj=1:sz(2)
                    for kk=1:sz(3)
                        B  = s*(sqrt(d(ii,jj,kk).EigValues));
                        if ~isempty(B)
                            xr = B(1)/2;
                            yr = B(2)/2;
                            zr = B(3)/2;
                            [x,y,z] = ellipsoid(xc,yc,zc,xr,yr,zr,n);
                            
                            % Transformer V
                            Q = d(ii,jj,kk).EigVectors;
                            if isempty(Q)
                                q = d(ii,jj,kk).Orientation;
                                Q = quat2mat(q);
                            end
                            if isnan(Q)
                                display(ii);
                                display(jj);
                                display(d(ii,jj,kk).Orientation);
                            end
                            for i=1:n+1
                                for j=1:n+1
                                    a = [x(i,j) y(i,j) z(i,j)]';
                                    A = Q*a;
                                    x(i,j) = A(1);
                                    y(i,j) = A(2);
                                    z(i,j) = A(3);
                                end
                            end
                            x = x+(jj-1);
                            y = y+(ii-1);
                            z = z+(kk-1);
                            if strcmpi(typecol,'Dircol')
                                 T = Q*diag(B)*Q';
                                 col = abs(diag(T));
                                 col = col/max(col);
                            else 
                                if abs(maxHA-minHA)>1e-5
                                    xcol= 1-((getHA(d(ii,jj,kk))-minHA)/(maxHA-minHA));
                                else
                                    xcol= 0;
                                end
                            col= [1 xcol 0];
                            end
                            
%                             if col(1)==col(2) && col(2)==col(3)
%                                 col = zeros(3,1);
%                             end
                            surf(x,y,z,'EdgeColor','none','FaceColor',col);
                        end
                    end
                end
            end
            axis image
            axis xy
            light
            lighting gouraud
            view(3)
            rotate3d on
            xlabel('axis i'), ylabel('axis j'), zlabel('axis k')
        end
        
        %% OBJECT METHODS: distance, (weighted) averaging & std.
        function di = dist(d1,d2,method)
            % di = dist(d1,d2,method)
            %
            % Distance between tensors, passed as 2 arguments:
            % - if d1 & d2 are tensors, distance between the 2
            % - if arrays of same size, distance element by element
            % - if d1=tensor & d2=tensor_array, distance between 1 and all
            %
            % Distance can be computed by "log-Euclidian" metric or
            % "SQ decomposition". Specified in 3rd argument by 'SQ' 
            % or 'LogE'. By default, distance is 'SQ'.
            
            if nargin<3
                method = 'SQ';
            end
            
            if numel(d1)==1 && numel(d2)==1
                sz = 1;
                one_vs_others = true;
            elseif numel(d1)==1 && numel(d2)>1
                sz = size(d2);
                one_vs_others = true;
            elseif numel(d1)>1 && numel(d1)==numel(d2)
                % check array size
                sz1 = size(d1);
                sz2 = size(d2);
                if ~all(sz1==sz2)
                    error('[difftensor] Invalid tensor array size for distance.');
                end
                sz = sz1;
                one_vs_others = false;
            else
                error('[difftensor] Invalid input for tensor distance.');
            end
            
            % initialize output
            di = zeros(sz);
            
            % loop through all elements
            for ii=1:prod(sz)
                if one_vs_others
                    dt1 = d1;
                    dt2 = d2(ii);
                else
                    dt1 = d1(ii);
                    dt2 = d2(ii);
                end
                switch method
                    % switch between distance metrics
                    case 'SQ'
                        di(ii) = dist_SQ(dt1,dt2);
                    case 'LogE'
                        di(ii) = dist_LE(dt1,dt2);
                    otherwise
                        error('[difftensor] Unknown distance method.');
                end
            end
        end
        
        function d_mean = wmean(di,w,method,rescale)
            % d_mean = wmean(di,w,method,rescale)
            %
            % Average between all tensors, using the 'SQ' or
            % 'LogE' metric. A weighted mean is possible, depending on the 
            % value of w. If using SQ, rescale enables to modify the
            % weights for the quaternion interpolation.
            % - 'kappa' : the weights are computed following Eq. (40) of 
            % A. Collard, S. Bonnabel, C. Phillips and R. Sepulchre,
            % 'Anisotropy preserving DTI processing'.
            % - 'no' : no rescaling is used, weights w are used.
            % - 'HA' : the weights are multiplied by the anisotropy of the
            % tensor (and then normalized).
            %
            % By default, 
            %   w = 1/#tensors, 
            %   rescale is 'kappa', and
            %   method is 'SQ'.
            
            % Default method            
            if nargin<4
                rescale = 'kappa';
            end
            if nargin<3
                method = 'SQ';
            end
            % Prepare input
            if numel(di)==1
                d_mean = di;
                return
            else
                num_dt = numel(di);
            end
            if nargin<2
                w = ones(num_dt,1)/num_dt;
            elseif numel(w)==1
                w = ones(num_dt,1)*w;
            elseif size(w,1)==1
                w = w';
            elseif numel(w)~=num_dt
                error('[difftensor] Incorrect number of weights');
            end
            
            A = find(w==1);
            if ~isempty(A)
                d_mean = di(A);
            else
            switch method
                case 'SQ'
                    E = zeros(3,1);
                    for ii=1:num_dt
                        E = E + w(ii)*log(di(ii).EigValues);
                    end
                    Eval_m = exp(E);
                    HAm = calcHA(Eval_m);
                    HAi= getHA(di);
%                     display(HAi);
                    % k parameters
                    if strcmp(rescale,'kappa')
                    k = calck(HAi(:),HAm);
%                     display(k(:))
                    elseif strcmp(rescale,'no')
                        k = ones(num_dt,1);
                    elseif strcmp(rescale,'HA')
                        if HAm~=0
                            k = HAi(:)/HAm;
                        else 
                            k = zeros(num_dt,1);
                        end
                    end
%                     display(k(:));
                    sk = sum(k);
                    if sk == 0
                        kw = w;
                        sk = sum(kw);
                    else
                    kw = w .* k;
                    sk = sum(kw);
%                     display(kw/sk)
                    end
%                     display(kw./sk);
                    % find reference tensor/quaternion
                    [~,Iwmax] = max(kw);
                    qr = di(Iwmax).Orientation;
                    qm = qr*kw(Iwmax)/sk;
                    % find other realigned quaternions, 
                    % and compute the mean
                    for ii=1:num_dt
                        if ii~=Iwmax
                            Q2  = di(ii).setQ;
                            if isempty(Q2)
                                Q2 = getSetQ(di(ii).Orientation);
                            end
                            q2n = realignQ(qr,Q2);
                            qm  = qm + kw(ii)*q2n/sk;
                        end
                    end
                    qm = qm/norm(qm);
                    if isnan(qm)
                        display(qm);
                        display(w);
                        display(k)
                        display(kw);
                        display(qr);
                        display(HAi(:));
                        display(HAm);
                    end
                    d_mean = difftensor;
                    d_mean.EigValues = Eval_m;
                    d_mean.Orientation = qm;
                    d_mean.EigVectors = quat2mat(qm);
                   % display(d_mean.HA);
%                     d_mean.HA = HAm;
%                     d_mean.setQ = getSetQ(qm);
                    
                case 'LogE'
                    Lt = zeros(3,3);
                    for ii=1:num_dt
                        R = di(ii).EigVectors;
                        if isempty(R)
                            R = quat2mat(di(ii).Orientation);
                        end
                        Ln = R*diag(log(di(ii).EigValues))*R';
                        Lt = Lt + w(ii)*Ln;
                    end
                    d_mean = difftensor(Sexpm(Lt));
                    
                otherwise
                    error('[difftensor] Unknow tensor metric');
            end
            end
        end
        
        function d_mean = mean(di,method,rescale,opt)
            %  d_mean = mean(di,method,rescale,opt)
            %
            % Estimate the mean of a 2D array of tensors.
            % Should have about the same behaviour as the 'mean' operator on an
            % array of scalar, i.e. column wise mean.
            % Using the 'SQ'(def.) or 'LogE' metric, as stated by 'method'.
            % If 'SQ' is used, rescale can be used to modify the weights
            % associated to the quaternion interpolation (by default, the
            % rescale is 'kappa').
            % The mean can be "robust", i.e. only of the non-empty tensors
            % by setting 'robust' for opt.
            if nargin<4, opt = 'classic'; end
            if nargin<3, rescale = 'kappa'; end
            if nargin<2, method = 'SQ';  end
            sz = size(di);
            if length(sz)>2
                error('[difftensor] Arrays must be 2D at most.');
            end
            if all(sz==1)
                % no avergaing needed
                d_mean = di;
            elseif any(sz==1)
                % simply average all element, row or column.
                l_nz = ~isempty(di);
                switch opt
                    case 'classic'
                        if all(l_nz)
                            d_mean = wmean(di(:),1/prod(sz),method,rescale);
                        else
                            d_mean = difftensor;
                        end
                    case 'robust'
                        if any(l_nz)
                            d_mean = wmean(di(l_nz),1/sum(l_nz),method,rescale);
                        else
                            d_mean = difftensor;
                        end
                    otherwise
                        error('[difftensor] Wrong options: ''classic'' or ''robust''.');
                end
                
            else
                d_mean(1,sz(2)) = difftensor;
                l_nz = ~isempty(di);
                for ii=1:sz(2)
                    switch opt
                        case 'classic'
                            if all(l_nz(:,ii))
                                d_mean(ii) = wmean(di(:,ii),1/sz(1),method,rescale);
                            else
                                d_mean(ii) = difftensor;
                            end
                        case 'robust'
                            if any(l_nz(:,ii))
                                d_mean(ii) = wmean(di(l_nz(:,ii),ii),1/sum(l_nz(:,ii)),method,rescale);
                            else
                                d_mean(ii) = difftensor;
                            end
                        otherwise
                            error('[difftensor] Arrays must be of the same dimensions.');
                    end
                end;
            end
        end
        
        function s = std(di,method,rescale)
            % s = std(di,method)
            %
            % Estimate the standard deviation (std) of an array of tensors
            % around its mean.
            % Should have about the same behviour as the 'std' operator on
            % an array of scalar, i.e. column wise std.
            
            if nargin<3, rescale = 'kappa'; end
            if nargin<2, method = 'SQ'; end
            sz = size(di);
            if length(sz)>2
                error('[difftensor] Arrays must be 2D at most.');
            elseif all(sz<3)
                % no std possible
                s = [];
            elseif any(sz==1)
                % std of all element, row or column.
                % s = st_dev(di,method);
                dm = mean(di,method,rescale);
                D = dist(dm,di,method);
                s = sqrt(sum(D.^2))/prod(sz);
            else
                s = zeros(1,sz(2));
                for ii=1:sz(2)
                    % s(ii) = st_dev(di(:,ii),method);
                    dm = mean(di(:,ii),method);
                    D = dist(dm,di(:,ii),method);
                    s(ii) = sqrt(sum(D.^2))/prod(sz);
                end
            end
        end
        
    end
    
end

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% SUBFUNCTIONS : Utility functions
%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function q = mat2quat(V)
% Turning the eigenvectors into a quaternion

tr = trace(V);
r = sqrt(1+V(1,1)-V(2,2)-V(3,3));

if abs(tr+1)<1e-6 && r~=0
    q = mat2quat_2(V);
else
    theta = real(acos((tr-1)/2));
    if mod(theta,2*pi)~=0
        w = [V(3,2)-V(2,3) ; V(1,3)-V(3,1) ; V(2,1)-V(1,2)] ...
            / (2*sin(theta)) ;
    else
        w = zeros(3,1);
    end
    a = cos(theta/2);
    V = w*sin(theta/2);
    
    q = [a ; V];
    q = q/norm(q);
end
end

function q = mat2quat_2(V)
% Other way of turning the eigenvectors into a quaternion
r = sqrt(1+V(1,1)-V(2,2)-V(3,3));
% if r==0
%   q= mat2quat(V);
% else
q = zeros(4,1);
q(1) = (V(3,2)-V(2,3))/(2*r);

q(2) = r/2;
q(3) = (V(1,2)+V(2,1))/(2*r);
q(4) = (V(3,1)+V(1,3))/(2*r);
end

function q2n = realignQ(q1,Q2)
% Realigning quaternion_2 (single q or set of 8 orients) on quaternion_1
if size(Q2,2)==1
    Q2 = getSetQ(Q2);
end
a = q1'*Q2;
[~,I_N] = max(a);
q2n = Q2(:,I_N);
end

function qm = multiplication(q1,q2)
% Multiplying 2 quaternions
qm = zeros(4,1);
qm(1) = q1'*[q2(1); -q2(2); -q2(3); -q2(4)];
qm(2) = q1(1)*q2(2)+ q2(1)*q1(2)+ q1(3)*q2(4)-q1(4)*q2(3);
qm(3) = q1(1)*q2(3)+ q2(1)*q1(3)+ q1(4)*q2(2)-q1(2)*q2(4);
qm(4) = q1(1)*q2(4)+q2(1)*q1(4)+ q1(2)*q2(3)-q1(3)*q2(2);
end

function R = quat2mat(q)
% Turning a quaternion into a rotation matrix/eigenvectors
a = q(1);
V = q(2:4);
theta = 2*acos(a);

if theta==0
    w = [0 0 0];
else
    w = V/sin(theta/2);
end

w_hat = [0 -w(3) w(2); w(3) 0 -w(1); -w(2) w(1) 0];
R = expm(w_hat*theta);
% R = Rexpm(w_hat*theta);
end

function di = realignD(q1,Q2)
% Distance between set of quaternions.
a  = q1'*Q2;
di = max(a);
di = 2-2*di;
end

function Q = getSetQ(q)
% Get 8 permutations of quaternion
Q = [q(1) -q(1)   q(2) -q(2)   q(3) -q(3)  q(4) -q(4) ;
    q(2) -q(2)  -q(1)  q(1)   q(4) -q(4) -q(3)  q(3) ;
    q(3) -q(3)  -q(4)  q(4)  -q(1)  q(1)  q(2) -q(2) ;
    q(4) -q(4)   q(3) -q(3)  -q(2)  q(2) -q(1)  q(1) ];
end

function RA = calcRA(v)
% Calculate RA
lambdam = sum(v)/3;
RA = sqrt(sum((v-lambdam*ones(3,1)).^2)) / lambdam / sqrt(6);
end

function FA = calcFA(v)
% Calculate FA
lambdam = sum(v)/3;
FA = sqrt(3/2) * sqrt(sum( (v-lambdam).^2 )) / sqrt(sum(v.^2));
end

function HA = calcHA(v)
% Calculate HA

% Check the ordering of the eigenvalues
v = sort(v,'descend');
HA = log(v(1)/v(3));

end

function dLE = dist_LE(d1,d2)
% calculate Log-Euclidian distance between 2 tensors
R1 = d1.EigVectors;
if isempty(R1)
    v = d1.Orientation;
    R1 = quat2mat(v);
end

R2 = d2.EigVectors;
if isempty(R2)
    v = d2.Orientation;
    R2 = quat2mat(v);
end
L1 = R1*diag(log(d1.EigValues))*R1';
L2 = R2*diag(log(d2.EigValues))*R2';
A  = L1 - L2;
dLE = sqrt(trace(A'*A));
end

function SdQ = dist_SQ(d1,d2)
% calculate SQ distance between 2 tensors

% distance according to eigenvalues
L1 = log(d1.EigValues);
L2 = log(d2.EigValues);
dist_v = sum((L2-L1).^2);
% distance accroding to orientation, depending on k
k = calck(getHA(d1),getHA(d2));
if k<1e-4
    % no angular information
    SdQ = sqrt(dist_v);
else
    % with angular information
    d2.setQ = getSetQ(d2.Orientation);
    dist_Q = realignD(d1.Orientation,d2.setQ);
    if dist_Q <1e-4
        dist_Q = 0;
    end
    SdQ = k*sqrt(dist_Q) + sqrt(dist_v);
end
end

function k = calck(HA1,HA2)
% weighting of eigenvector distance
d1= size(HA1);
d2= size(HA2);
alpha = 0.6;
if prod(d1)~= prod(d2) && prod(d2) == 1
    k = zeros(prod(d1),1);
    for ii=1 : prod(d1)
        xB = alpha*min(HA1(ii),HA2);
        k(ii) = xB^4/(1+xB^4);
    end

elseif prod(d1)==prod(d2)
    k = zeros(prod(d1),1);
    for ii=1 : prod(d1)
        xB = alpha*min(HA1(ii),HA2(ii));
        k(ii) = xB^4/(1+xB^4);
    end

else
    error('[difftensor] Problem of dimension to compute k');
end
end

function S = Sexpm(L)
% matrix exponential
[v,d] = eig(L);
S = v*diag(exp(diag(d)))*v';
end

