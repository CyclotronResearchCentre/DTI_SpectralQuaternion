classdef difftensor
    % DIFFTENSOR
    % "Diffusion tensor" class definition and operators
    % overloading/definition.
    %
    % D = difftensor(F)
    % A tensor object can be generated by passing F as
    % - a 3x3 (tensor) matrix
    % - a cell array of 3x3 (tensor) matrices or 6 cell arrays (one per
    %   component of the tensor) or N-D matrices.
    % - a 4D/3D/2D array (Nx x Ny x Nz x 6) with tensor's 6 components 
    %     (xx, xy,xz, yy, yz, zz)
    %
    % Options:
    % - when passing 6 components, the default order is [Dxx Dxy Dxz Dyy 
    %   Dyz Dzz] but an extra array argument can be passed to reorder these
    %   commonents. 
    %   E.g order = [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz] and
    %   D = difftensor(F,order)
    % - you can force to take the absolute value of the eigenvalues of the
    %   3x3 passed (or created from the 6 components) to ensure it is
    %   positive demi-definite, by passing an extra char argument 'abs'.
    %   E.g. D = difftensor(F,'abs') or D = difftensor(F,order,'abs')
    %
    % Each tensor is defined internally only by its:
    %   - eigenvalues (EigValues), sorted in descending order
    %   - orientation (Orientation), expressed as a quaternion
    %   - eigenvectors (EigVectors), this is redundant but efficient for
    %       logE calculation
    % Tensor can be organised in arrays of "any" size.
    %
    % METHODS:
    %   difftensor    - building of the tensor (array)
    %   dist          - distance between tensors, SQ or logE
    %   getDet        - get determinant(s)
    %   getFA         - get the FA value(s)
    %   getRA         - get the RA value(s)
    %   getHA         - get the HA value(s)
    %   getTensor     - get the tensor(s)
    %   getTr         - get the trace(s)
    %   get1stEV      - get the 1st eigenvector (main direction)
    %   maxEV         - get largest eigen value
    %   minEV         - get smallest eigen value
    %   dist          - distance between 2 tensors, with SQ or LogE metric
    %   wmean         - weighter mean of all array
    %   mean          - mean of tensors, column-wise
    %   std           - standard deviation of distance around mean tensor
    %   wmean2dt      - 1D linear interpolation between a pair of tensors
    %   rotate        - rotate tensor(s)
    %   affine        - apply affine transformation, with 'preserve
    %                   principal direction' algorithm
    %   scale         - rescale tensor(s)
    %   text_display  - display as text
    %   graph_display - display graphically (up to 3D arrays)as ellipses
    %   vect_display  - display the main vector, weighted by the FA
    %   isempty       - overloaded function for difftensor
    %______________________________________________________________________
    % Copyright (C) 2011 University of Liege, Belgium
    
    % Written by A. Collard & C. Phillips, 2013.
    % Dept of Electrical Engineering and Computer Science &
    % Cyclotron Research Centre, University of Liege, Belgium

    
    %% PROPERTIES
    properties
        EigValues   % eigen values, sorted in descending order
        Orientation % eigenvectors expressed as a quaternion
        EigVectors  % eigenvectors (this is redundant but more efficient
%                     for logE calculation)
        
    end
    
    properties (SetAccess = private)
        HA
        setQ
        
    end
    
    methods
        %% OBJECT DEFINITION: set tensor, eigenvalues & orientation
        function d = difftensor(F,varargin)
            % Allow nargin == 0 syntax
            if nargin ~= 0 && iscell(F)
                if ndims(F)==2 && length(F)==6
                    % Input as 6 cell arrays with the 6 tensor elements
                    
                    % Handle special cases: different ordering of
                    % components and taking the abs-value of eigen values.
                    if nargin==1
                        order = [1 2 3 4 5 6];
                        % for [Dxx Dxy Dxz Dyy Dyz Dzz] by default
                        aEigVal = false;
                    elseif nargin==2
                        if isnumeric(varargin{1})
                            order = varargin{1};
                            % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                            if numel(order)~=6
                                warning('difftensor:order', ...
                                    '[difftensor] Wrong ''order'' size, using default.'); %#ok<*WNTAG>
                                order = [1 2 3 4 5 6];
                            end
                            aEigVal = false;
                        elseif ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                            order = [1 2 3 4 5 6];
                        else
                            error('[difftensor] Wrong input to create tensor (array).');
                        end
                    elseif nargin==3
                        order = varargin{1};
                        % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                        if numel(order)~=6
                            warning('difftensor:order', ...
                                '[difftensor] Wrong ''order'' size, using default.');
                            order = [1 2 3 4 5 6];
                        end
                        if strcmpi(varargin{2},'abs')
                            aEigVal = true;
                        else
                            aEigVal = false;
                        end
                    else
                        error('[difftensor] Wrong input to create tensor (array).');
                    end
                    
                    % Build tensor array
                    sz = size(F{1});
                    d(prod(sz)) = difftensor; % Preallocate object array
                    for ii = 1:prod(sz)
                        tmp = [ ...
                            F{order(1)}(ii) F{order(2)}(ii) F{order(3)}(ii) ; ...
                            F{order(2)}(ii) F{order(4)}(ii) F{order(5)}(ii) ; ...
                            F{order(3)}(ii) F{order(5)}(ii) F{order(6)}(ii) ];
                        d(ii) = difftensor(tmp,aEigVal);
                    end
                    d = reshape(d,sz);
                else
                    % Input as cell array, each cell being a 3x3 array
                    if nargin==1
                        aEigVal = false;
                    elseif nargin==2
                        if ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                        
                        else
                            error('[difftensor] Wrong input to create tensor (array).');
                        end
                    end
                    sz = size(F); % allow any cell-array size
                    d(prod(sz)) = difftensor; % Preallocate object array
                    for ii = 1:prod(sz)
                        d(ii) = difftensor(F{ii},aEigVal);
                    end
                    d = reshape(d,sz);
                end
                
            elseif nargin ~=0 && ~iscell(F)
                % Input as numerical array in various format
                if ~isnumeric(F)
                    error('[difftensor] The diffusion tensor must be a 3x3 matrix.');
                end
                if ndims(F)==2 && all(size(F)==[3 3])
                    % 3x3 array
                    % Take the absolute value of eigenvalues, or not?
                    if nargin==1
                        aEigVal = false;
                    else
                        aEigVal = logical(varargin{1});
                    end
                    % Build tensor
                    [V,E] = eig(F);
                    if aEigVal, E = abs(E); end
                    if sum(sign(diag(E)))<3
                        warning('difftensor:eigval', ...
                            '[difftensor] The diffusion tensor must be positive.');
                        d = difftensor; % returning empty tensor
                        return
                    end
                    d.EigValues = diag(E);
                    V = det(V)*V;
                    [~, I] = sort(diag(E),'descend');
                    V1 = [V(:,I(1)) V(:,I(2)) V(:,I(3))];
                    V1 = V1*det(V1);
                    q1 = mat2quat(V1);
                    d.EigVectors = V1;
                    d.Orientation = q1;
                    d.HA = calcHA(d.EigValues);
                    d.setQ = getSetQ(q1);
                elseif  (ndims(F)==4 && size(F,4)==6) || ...
                        (ndims(F)==3 && size(F,3)==6) || ...
                        (ndims(F)==2 && length(F)==6)
                    % 4D/3D/2D array Nx (x Ny) (x Nz) x 6 array,
                    % as in 3D/2D/1D x 6 images
                    % The last dimension should always be of size 6!
                    
                    % Handle special cases: 
                    %   - different ordering of components and,
                    %   - taking the abs-value of eigen values or not.
                    if nargin==1
                        order = [1 2 3 4 5 6];
                        % for [Dxx Dxy Dxz Dyy Dyz Dzz] by default
                        aEigVal = false;
                    elseif nargin==2
                        if isnumeric(varargin{1})
                            order = varargin{1};
                            % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                            if numel(order)~=6
                                warning('difftensor:order',...
                                    '[difftensor] Wrong ''order'' size, using default.');
                                order = [1 2 3 4 5 6];
                            end
                            aEigVal = false;
                        elseif ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                            order = [1 2 3 4 5 6];
                        else
                            error('[difftensor] Wrong input to create tensor (array).');
                        end
                    elseif nargin==3
                        order = varargin{1};
                        % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                        if numel(order)~=6
                            warning('difftensor:order', ...
                                '[difftensor] Wrong ''order'' size, using default.');
                            order = [1 2 3 4 5 6];
                        end
                        if strcmpi(varargin{2},'abs')
                            aEigVal = true;
                        else
                            aEigVal = false;
                        end
                    else
                        error('[difftensor] Wrong input to create tensor (array).');
                    end
                    
                    sz = size(F);
                    % Special case of 6 elements as a 6x1 vector
                    if ndims(F)==2 && sz(1)==6 && sz(2)==1
                        F = F';
                        sz = size(F);
                    end
                    
                    % Create tensor array
                    F = reshape(F,prod(sz(1:end-1)),6)';
                    d(prod(sz(1:end-1))) = difftensor; % allocate object array
                    for ii = 1:prod(sz(1:end-1))
                        tF = F(order,ii);
                        tmp = [ tF(1) tF(2) tF(3) ; ...
                                tF(2) tF(4) tF(5) ; ...
                                tF(3) tF(5) tF(6) ];
                        d(ii) = difftensor(tmp,aEigVal);
%                         if sum(tF([1 4 6]))>0
%                             tmp = [ tF(1) tF(2) tF(3) ; ...
%                                 tF(2) tF(4) tF(5) ; ...
%                                 tF(3) tF(5) tF(6) ];
%                             d(ii) = difftensor(tmp);
%                         else
%                             % dealing with case of voxel with zero's
%                             d(ii) = difftensor;
%                         end
                    end
                    if length(sz)>2 % 3D/2D array only
                        d = reshape(d,sz(1:end-1));
                    end
                else
                    error('[difftensor] Unknown input format.');
                end
            end
        end
        
        function obj = set.EigValues(obj,value)
            % Eigenvalues are sorted in descending order.
            % Their positiveness is checked!
            if sum(sign(value))<3 || numel(value)~=3
                display(value);
                error('difftensor:eigval', ...
                    '[difftensor] The diffusion tensor must be positive.');
            end
            value = sort(value,'descend');
            obj.EigValues = value(:);
        end
        
        function obj = set.Orientation(obj,value)
            % The dimension and norm of the quaternion are checked.
            if abs(norm(value)-1)>10e-5 || numel(value)~=4
                error('difftensor:quaternion', ...
                    '[difftensor] Orientation must be given by a unit quaternion.');
            end
            obj.Orientation = value(:);

        end
        
        function obj = set.EigVectors(obj,value)
            % The dimension and norm of the rotation matrix are checked.
            if numel(value)==4 && abs(norm(value)-1)<10e-5
                value = quat2mat(value);
            end
            if abs(det(value)-1)>10e-5 || numel(value)~=9
                error('difftensor:eigvect', ...
                    '[difftensor] Eigenvectors must be given by a rotation matrix.');
            end
            obj.EigVectors = value(:,:);
        end
        
        function obj = set.HA(obj,value)
            % HA set method
            obj.HA = value;
        end
        
        function obj = set.setQ(obj,value)
            % setQ set method
            if numel(value)==4
                obj.setQ= getSetQ(value);
            else
                obj.setQ = value;
            end
        end
        
        %% OBJECT METHODS: overloading some simple functions
        %%
        
        function out = isempty(obj)
            % check for empty tensor
            sz = size(obj);
            out = zeros(sz);
            for ii=1:prod(sz)
                out(ii) = isempty(obj(ii).EigValues);
            end
        end
        
        %% OBJECT METHODS: get tensor, determinant, trace, RA, FA,
        %%                 1st EigVector, max EigValues, min EigValues
        %%
        
        function T = getTensor(obj,opt)
            % get the (rebuilt) tensors
            if nargin<2, opt = 'cll'; end
            sz = size(obj);
            if prod(sz)==1
                if ~isempty(obj)
                    R = quat2mat(obj.Orientation);
                    T = R*diag(obj.EigValues)*R';
                else
                    T = [];
                end
            else
                switch opt
                    case 'cll'
                        % Output as cell array of tensors
                        T = cell(sz);
                        for ii=1:prod(sz);
                            if ~isempty(obj(ii))
                                R = quat2mat(obj(ii).Orientation);
                                T{ii} = R*diag(obj(ii).EigValues)*R';
                            else
                                T{ii} = [];
                            end
                        end
                    case 'img'
                        % Output as 'image' component (sz x 6)
                        T = zeros(prod(sz),6);
                        for ii=1:prod(sz);
                            if ~isempty(obj(ii))
                                R = quat2mat(obj(ii).Orientation);
                                tmp = R*diag(obj(ii).EigValues)*R';
                                T(ii,:) = [tmp(1) tmp(2) tmp(3) ...
                                    tmp(5) tmp(6) tmp(9)];
                            end
                        end
                        T = reshape(T,[sz, 6]);
                end
            end
        end
        
        function EV1 = get1stEV(obj)
            % Get the 1st eigenvector
            sz = size(obj);
            EV1 = zeros([prod(sz),3]);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    EV1(ii,:) = obj(ii).EigVectors(:,1)';
                end
            end
            if prod(sz)>1
                EV1 = reshape(EV1,[sz 3]);
            else
                EV1 = EV1';
            end
        end
        
        function dete = getDet(obj)
            % Det get method
            sz = size(obj);
            dete = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    dete(ii) = prod(obj(ii).EigValues);
                end
            end
        end
        
        function tr = getTr(obj)
            % trace get method
            sz = size(obj);
            tr = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    tr(ii) = sum(obj(ii).EigValues);
                end
            end
        end
        
        function RA = getRA(obj)
            % RA get method
            sz = size(obj);
            RA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    RA(ii) = calcRA(obj(ii).EigValues);
                end
            end
        end
        
        function FA = getFA(obj)
            % FA get method
            sz = size(obj);
            FA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    FA(ii) = calcFA(obj(ii).EigValues);
                end
            end
        end
        
        function HA = getHA(obj)
            % HA get method
            sz = size(obj);
            HA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    HA(ii) = calcHA(obj(ii).EigValues);
                end
            end
        end
        
        function M_ev = maxEV(obj)
            % Get largest EigValues
            sz = size(obj);
            M_ev = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    M_ev(ii) = obj(ii).EigValues(1);
                end
            end
        end
        
        function m_ev = minEV(obj)
            % Get smallest EigValues
            sz = size(obj);
            m_ev = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    m_ev(ii) = obj(ii).EigValues(3);
                end
            end
        end
        
        %% OBJECT METHODS: apply rotation, affine & scale
        function dr = rotate(d,R)
            % Rotate d by R (3x3 matrix).
            % - if R is a single rot matrix -> apply on all elements of d
            % - if R is a cell-array of rot matrices and d has the same
            %   size as d -> apply rotation element by element
            
            dr = d;
            if iscell(R) && all(size(d)==size(R))
                % apply rotation element by element
                for ii=1:numel(d)
                    if all(size(R{ii})==[3 3]) && abs(det(R{ii})-1)>1e-10
                        error('[difftensor] R must be a rotation matrix');
                    end
                    qR = mat2quat(R{ii});
                    QR = [qR -qR];
                    qR_R = realignQ(d(ii).Orientation,QR);
                    qnew = multiplication(qR_R,d(ii).Orientation);
                    dr(ii).Orientation = qnew;
                    dr(ii).setQ = getSetQ(qnew);
                    dr(ii).EigVectors = quat2mat(qnew);
                end
            elseif isnumeric(R)
                % apply same rotation matrix to all tensors
                if all(size(R)==[3 3]) && abs(det(R)-1)>1e-10
                    display(R)
                    error('[difftensor] R must be a rotation matrix');
                end
                qR = mat2quat(R);
                QR = [qR -qR];
                for ii=1:numel(d)
                    if ~isempty(d(ii))
                        qR_R = realignQ(d(ii).Orientation,QR);
                        qnew = multiplication(qR_R,d(ii).Orientation);
                        dr(ii).Orientation = qnew;
                        dr(ii).setQ = getSetQ(qnew);
                        dr(ii).EigVectors = quat2mat(qnew);
                        
                    end
                end
            else
                error('[difftensor] Invalid rotation operation.');
            end
        end
        
        function dr = rotate_q(d,qR)
            % Rotate d by qR (quaternion).
            % - if R is a single unit quaternion -> apply on all elements of d
            % - if R is a cell-array of quaternions and d has the same
            %   size as d -> apply rotation element by element
            
            dr = d;
            if iscell(qR) && all(size(d)==size(qR))
                % apply rotation element by element
                for ii=1:numel(d)
                    if all(size(qR{ii})==[4 1]) && abs(norm(qR{ii})-1)>1e-10
                        error('[difftensor] qR must be a cell of unit quaternions');
                    end
                    QR = [qR{ii} -qR{ii}];
                    qR_R = realignQ(d(ii).Orientation,QR);
                    qnew = multiplication(qR_R,d(ii).Orientation);
                    dr(ii).Orientation = qnew;
                end
            elseif isnumeric(qR)
                % apply same rotation matrix to all tensors
                if all(size(qR)==[4 1]) && abs(norm(qR)-1)>1e-10
                    error('[difftensor] qR must be a unit quaternion');
                end
                QR = [qR -qR];
                for ii=1:numel(d)
                    qR_R = realignQ(d(ii).Orientation,QR);
                    qnew = multiplication(qR_R,d(ii).Orientation);
                    dr(ii).Orientation = qnew;
                end
            else
                error('[difftensor] Invalid rotation operation.');
            end
        end
        
        function da = affine(d,F)
            % Tensor d and affine transformation F (3x3 mtrix)
            % The rotation associated with the 'deformation part' F
            % of an affine transform (i.e. without the translation
            % component) is estimated in order to "preserve the principal
            % direction" (PPD) of tensor d.
            %
            % The rotation matrix R so derived depends on F but also on the
            % eigenvectors EV of the tensor that is transformed!
            % Reference:
            % D.C. Alexander, C. Pierpoli, P.J. Basser and J.C. Gee,
            % Spatial Transformations of Diffusion Tensor Magnetic
            % Resonance Images, IEEE Transactions on Medical Imaging,
            % 20(11):1131-1139.
            
            EV = d.EigVectors;
            n1 = F*EV(:,1); n1 = n1/norm(n1);
            n2 = F*EV(:,2); n2 = n2/norm(n2);
            
            % 1st rotation
            r1 = vectprod(EV(:,1),n1); r1 = r1/norm(r1);
            theta1 = acos(EV(:,1)'*n1);
            R1 = buildrot(r1,theta1);
            
            % 2nd rotation
            Pn2 = n2 - (n2'*n1)*n1;
            theta2 = acos((R1*EV(:,2))' * (Pn2/norm(Pn2)));
            r2 = R1*EV(:,1);
            R2 = buildrot(r2,theta2);
            
            % combine the 2 rotations & apply
            R = real(R1*R2);
            da = rotate(d,R);
        end
        
        function d_trans= rigid_warp(d,M,t,method,rescale)
            % Apply a (rigid) spatial transformation to a difftensor field
            % !! Limited to 3D images

            % d: difftensor field
            % M: linear transformation matrix (3x3)
            % t: rigid translation (3x1)
            
            % method can be 'SQ' or 'LogE'. If the used method is SQ,
            % rescale can be used to modify the weights associated to the
            % quaternion interpolation.

            % 'Linear' interpolation method
            if nargin<5
                rescale = 'kappa';
            end
            if nargin<4
                method = 'SQ';
                rescale = 'kappa';
            end
            ds= size(d);
            if length(ds)>3
                error('[difftensor] Spatial transform are restricted to 3D fields.');
            end


            % "zero" difftensor

            F= difftensor(0.005*eye(3));
            R= (M*M')^(-1/2)*M;
            d_trans= difftensor;
            l= ds(1);
            lm = ceil(l/2);
            m= ds(2);
            mm = ceil(m/2);
            if length(ds)<3
                h=1;
            else
                h = ds(3);
            end

            for ii=1:l
                for jj=1:m
                    for kk=1:h
                        x= [ii-lm,jj-mm,kk]';
                        M1x= M*x;
                        Mtx= M1x+t;

                        % rotation autour du milieu
                        Mtx = Mtx+ [lm mm 0]';

                        % Calcul de f(M1x) par interpolation
                    i1= floor(Mtx(1)); i2= ceil(Mtx(1));

                    j1= floor(Mtx(2)); j2= ceil(Mtx(2));

                    k1= floor(Mtx(3)); k2= ceil(Mtx(3));

                    if i1<=0 ||i2> l|| j1<=0 ||j2> m || k1<=0 || k2>h % ext�rieur
                        d_trans(ii,jj,kk)=F;
                    elseif Mtx(1)>=1 && Mtx(1)<=l && Mtx(2)>=1 && Mtx(2)<=m && Mtx(3)>=1 && Mtx(3)<=h %int�rieur
                    ind_i= [i1 i1 i2 i2 i1 i1 i2 i2]';
                    ind_j= [j1 j2 j1 j2 j1 j2 j1 j2]';
                    ind_k= [k1 k1 k1 k1 k2 k2 k2 k2]';

                    ind= (ind_k-ones(8,1))*m*l+ (ind_j-ones(8,1))*l+ ind_i;


                    L= d(ind);


                    xx= Mtx(1)-i1;
                    yy= Mtx(2)-j1;
                    zz= Mtx(3)-k1;
                    terme_i= ones(8,1)-[0 0 1 1 0 0 1 1]'+ xx*[-1 -1 1 1 -1 -1 1 1]';
                    terme_j= ones(8,1)-[0 1 0 1 0 1 0 1]'+ yy*[-1 1 -1 1 -1 1 -1 1]';
                    terme_k= ones(8,1)-[0 0 0 0 1 1 1 1]'+ zz*[-1 -1 -1 -1 1 1 1 1]';

                    w= terme_i.*terme_j.*terme_k;

                    WA = wmean(L,w,method,rescale);
            %         d_trans(ii,jj,kk)= affine(WA,M);
                    d_trans(ii,jj,kk) = rotate(WA,R);
            %           d_trans(ii,jj,kk)= WA;
                    end


                    end
                end
            end
        
        end

        
        function ds = scale(d,S)
            % Scale d by S
            % - if S is a cell-array of scaling (3x1) vectors and d is a
            %   difftensor array of the same size as S
            %       -> apply scaling eignvalue by eigenvalue and element
            %          by element
            % - if S is a scalar-array of scaling factor and d is a
            %   diftensor array of the same size as S
            %       -> apply scaling on 3 eigenvalues element by element
            % - if S is a 3x1 vector
            %       -> all the scaling on each eigenvalues of all elements
            % - if S is a single scalar
            %       -> apply the same scaling to all eigenvalues
            % S{ii}/S can thus be
            % - a scalar -> scale all eigenvalues by S
            % - a 3x1 vector -> scale each eigenvalue by corresponding S_i
            
            ds = d;
            if iscell(S) && all(size(d)==size(S))
                % apply 3x1 scaling element by element
                for ii=1:numel(d)
                    if any(S{ii}<0) || numel(S{ii})~=3
                        error('[difftensor] Invalid scaling operation.');
                    end
                    if ~isempty(d(ii))
                        ds(ii).EigValues = S{ii}(:).*d(ii).EigValues;
                    end
                end
                
            elseif isnumeric(S)
                if any(S<=0)
                    error('[difftensor] Scaling must be positive.');
                end
                if all(size(d)==size(S))
                    % apply scaling element by element
                    for ii=1:numel(d)
                        if ~isempty(d(ii))
                            ds(ii).EigValues = S(ii)*d(ii).EigValues;
                        end
                    end
                elseif numel(S)==3 || numel(S)==1
                    % apply same scaling to all elements
                    for ii=1:numel(d)
                        if ~isempty(d(ii))
                            ds(ii).EigValues = S.*d(ii).EigValues;
                        end
                    end
                else
                    error('[difftensor] Invalid scaling operation.');
                end
            else
                error('[difftensor] Invalid scaling operation.');
            end
        end
        
        %% OBJECT METHODS: display functions (text & plot)
        function text_display(d)
            % Rebuild the tensor and 'print' it
            for ii=1:numel(d)
                display(getTensor(d(ii)));
            end
        end
        
        function vect_display(d)
            % vect_display(d)
            %
            % Plot the 1st eigenvector of the tensor as a small line:
            % - the length is proportional to FA
            % - color is the RGB of the 1st eigenvector
            sz = size(d);
            if numel(sz)>3,
                error('[difftensor] Can only display up to 3D tensor array');
            elseif numel(sz)==2
                sz(3) = 1;
            elseif numel(sz)==1
                sz(2) = 1; sz(3) = 1;
            end
            figure
            hold on
            for ii=1:sz(1)
                for jj=1:sz(2)
                    for kk=1:sz(3)
                        if ~isempty(d(ii,jj,kk))
                            v = d(ii,jj,kk).EigVectors(:,1);
                            vw = v*getFA(d(ii,jj,kk))/2;
                            x = 1*(jj-1);
                            y = 1*(ii-1);
                            z = 1*(kk-1);
                            plot3([x+vw(1) x-vw(1)]',[y+vw(2) y-vw(2)]',...
                                [z+vw(3) z-vw(3)],'Color',abs(v)','LineWidth',2)
                            plot3(x,y,z,'ko')
                        end
                    end
                end
            end
            axis image
            axis xy
            light
            lighting gouraud
            view(3)
            rotate3d on
            xlabel('axis i'), ylabel('axis j'), zlabel('axis k')
        end
        
        function graph_display(d,s,typecol)
            % graph_display(d,s)
            %
            % Can plot single tensor or array of tensors, up to 3D, as
            % ellipsoids. These can be scaled by a scalar (s).
            
            if nargin<2,
                M_ev = maxEV(d);
                s = 1/sqrt(max(M_ev(:)));
                typecol = 'Dircol';
            elseif isempty(s)
                s = 1;
            elseif s<0
                M_ev = maxEV(d);
                s = -s*1/sqrt(max(M_ev(:)));
            elseif nargin<3
                typecol = 'Dircol';
            end
            
            n  = 20;
            xc = 0; yc = 0; zc = 0;
            sz = size(d);
            if numel(sz)>3,
                error('[difftensor] Can only display up to 3D tensor array');
            elseif numel(sz)==2
                sz(3) = 1;
            elseif numel(sz)==1
                sz(2) = 1; sz(3) = 1;
            end
            maxHA= max(max(getHA(d)));
            minHA= min(min(getHA(d)));
            figure
            hold on
            for ii=1:sz(1)
                for jj=1:sz(2)
                    for kk=1:sz(3)
                        B  = s*(sqrt(d(ii,jj,kk).EigValues));
                        if ~isempty(B)
                            xr = B(1)/2;
                            yr = B(2)/2;
                            zr = B(3)/2;
                            [x,y,z] = ellipsoid(xc,yc,zc,xr,yr,zr,n);
                            
                            % Transformer V
                            Q = d(ii,jj,kk).EigVectors;
                            if isnan(Q)
                                display(ii);
                                display(jj);
                                display(d(ii,jj,kk).Orientation);
                            end
                            for i=1:n+1
                                for j=1:n+1
                                    a = [x(i,j) y(i,j) z(i,j)]';
                                    A = Q*a;
                                    x(i,j) = A(1);
                                    y(i,j) = A(2);
                                    z(i,j) = A(3);
                                end
                            end
                            x = x+(jj-1);
                            y = y+(ii-1);
                            z = z+(kk-1);
                            if strcmpi(typecol,'Dircol')
                                 T = Q*diag(B)*Q';
                                 col = abs(diag(T));
                                 col = col/max(col);
                            else 
                                if abs(maxHA-minHA)>1e-5
                                    xcol= 1-((getHA(d(ii,jj,kk))-minHA)/(maxHA-minHA));
                                else
                                    xcol= 0;
                                end
                            col= [1 xcol 0];
                            end
                            
%                             if col(1)==col(2) && col(2)==col(3)
%                                 col = zeros(3,1);
%                             end
                            surf(x,y,z,'EdgeColor','none','FaceColor',col);
                        end
                    end
                end
            end
            axis image
            axis xy
            light
            lighting gouraud
            view(3)
            rotate3d on
            xlabel('axis i'), ylabel('axis j'), zlabel('axis k')
        end
        
        %% OBJECT METHODS: distance, (weighted) averaging & std.
        function di = dist(d1,d2,method)
            % di = dist(d1,d2,method)
            %
            % Distance between tensors, passed as 2 arguments:
            % - if d1 & d2 are tensors, distance between the 2
            % - if arrays of same size, distance element by element
            % - if d1=tensor & d2=tensor_array, distance between 1 and all
            %
            % Distance can be computed by "log-Euclidian" metric or
            % "SQ decomposition". Specified in 3rd argument by
            % 'SQ' or 'LogE'.
            % By default, distance is 'SQ'.
            
            if nargin<3
                method = 'SQ';
            end
            
            if numel(d1)==1 && numel(d2)==1
                sz = 1;
                one_vs_others = true;
            elseif numel(d1)==1 && numel(d2)>1
                sz = size(d2);
                one_vs_others = true;
            elseif numel(d1)>1 && numel(d1)==numel(d2)
                % check array size
                sz1 = size(d1);
                sz2 = size(d2);
                if ~all(sz1==sz2)
                    error('[difftensor] Invalid tensor array size for distance.');
                end
                sz = sz1;
                one_vs_others = false;
            else
                error('[difftensor] Invalid input for tensor distance.');
            end
            
            % initialize output
            di = zeros(sz);
            
            % loop through all elements
            for ii=1:prod(sz)
                if one_vs_others
                    dt1 = d1;
                    dt2 = d2(ii);
                else
                    dt1 = d1(ii);
                    dt2 = d2(ii);
                end
                switch method
                    % switch between distance metrics
                    case 'SQ'
                        di(ii) = dist_SQ(dt1,dt2);
                    case 'LogE'
                        di(ii) = dist_LE(dt1,dt2);
                    otherwise
                        error('[difftensor] Unknown distance method.');
                end
            end
        end
        
        function [k,dist_Q,rQ] = calc_grad_q(d1,d2)
            
                [k,dist_Q,rQ] = grad_q(d1,d2);
                
        end
        
        function d_mean = wmean(di,w,method,rescale)
            % d_mean = wmean(di,w,method,rescale)
            %
            % Weighted average between tensors, using the 'SQ' or
            % 'LogE' metric. If using SQ, rescale enables to modify the
            % weights for the quaternion interpolation.
            % By default weighting is 'kappa' and method is 'SQ'.
            
            % Default method
            if nargin<3
                rescale = 'kappa';
                method = 'SQ';
            end
            if nargin<4
                rescale = 'kappa';
            end
            % Prepare input
            if numel(di)==1
                d_mean = di;
                return
            else
                num_dt = numel(di);
            end
            if nargin<2
                w = ones(num_dt,1)/num_dt;
            elseif numel(w)==1
                w = ones(num_dt,1)*w;
            elseif size(w,1)==1
                w = w';
            elseif numel(w)~=num_dt
                error('[difftensor] Incorrect number of weights');
            end
            
            A = find(w==1);
            if ~isempty(A)
                d_mean = di(A);
            else
            switch method
                case 'SQ'
                    E = zeros(3,1);
                    for ii=1:num_dt
                        E = E + w(ii)*log(di(ii).EigValues);
                    end
                    Eval_m = exp(E);
                    HAm = calcHA(Eval_m);
                    HAi= getHA(di);
%                     display(HAi);
                    % k parameters
                    if strcmp(rescale,'kappa')
                    k = calck(HAi(:),HAm);
%                     display(k(:))
                    elseif strcmp(rescale,'no')
                        k = ones(num_dt,1);
                    elseif strcmp(rescale,'HA')
                        if HAm~=0
                            k = HAi(:)/HAm;
                        else 
                            k = zeros(num_dt,1);
                        end
                    end
%                     display(k(:));
                    sk = sum(k);
                    if sk == 0
                        kw = w;
                        sk = sum(kw);
                    else
                    kw = w .* k;
                    sk = sum(kw);
%                     display(kw/sk)
                    end
%                     display(kw./sk);
                    % find reference tensor/quaternion
                    [~,Iwmax] = max(kw);
                    qr = di(Iwmax).Orientation;
                    qm = qr*kw(Iwmax)/sk;
                    % find other realigned quaternions, 
                    % and compute the mean
                    for ii=1:num_dt
                        if ii~=Iwmax
                            Q2  = di(ii).setQ;
                            q2n = realignQ(qr,Q2);
                            qm  = qm + kw(ii)*q2n/sk;
                        end
                    end
                    qm = qm/norm(qm);
                    if isnan(qm)
                        display(qm);
                        display(w);
                        display(k)
                        display(kw);
                        display(qr);
                        display(HAi(:));
                        display(HAm);
                    end
                    d_mean = difftensor;
                    d_mean.EigValues = Eval_m;
                    d_mean.Orientation = qm;
                    d_mean.EigVectors = quat2mat(qm);
                    d_mean.HA = HAm;
                    d_mean.setQ = getSetQ(qm);
                    
                case 'LogE'
                    Lt = zeros(3,3);
                    for ii=1:num_dt
                        R = di(ii).EigVectors;
                        Ln = R*diag(log(di(ii).EigValues))*R';
                        Lt = Lt + w(ii)*Ln;
                    end
                    d_mean = difftensor(Sexpm(Lt));
                    
                otherwise
                    error('[difftensor] Unknow tensor metric');
            end
            end
        end
        
        function d_mean = wmean2dt(d1,d2,t,method,rescale)
            % d_mean = wmean2dt(d1,d2,t,method,rescale)
            %
            % Linear interpolation between 2 (arrays of) tensors.
            % The parameter 't' belongs to [0 1].
            % By default t = .5
            % Using the 'SQ' or 'LogE' metric, as defined by 'method'.
            % If SQ is used, rescale enables to modify the weight of the
            % quaternion interpolation. Default rescale is kappa.
            
            if nargin<4, method = 'SQ'; rescale = 'kappa'; end
            if nargin<5, rescale = 'kappa'; end
            if nargin<3,
                t = .5;
            else
                if t>1 || t<0
                    error('[difftensor] Weight ''t'' should be [0 1].');
                end
            end
            if numel(d1)==1 && numel(d2)==1
                dm = difftensor;
                dm(1) = d1;
                dm(2) = d2;
                d_mean = wmean(dm,[(1-t) t]',method,rescale);
            elseif numel(d1)==numel(d2)
                d_mean = d1;
                for ii=1:numel(d1)
                    dm = difftensor;
                    dm(1)= d1(ii);
                    dm(2)= d2(ii);
                    d_mean(ii)= wmean(dm,[(1-t) t]',method,rescale);
                end
            else
                error('[difftensor] Arrays must be of the same dimensions.');
            end
        end
        
        function d_mean = mean(di,method,rescale,opt)
            %  d_mean = mean(di,method,opt)
            %
            % Estimate the mean of a 2D array of tensors.
            % Should have about the same behaviour as the 'mean' operator on an
            % array of scalar, i.e. column wise mean.
            % Using the 'SQ'(def.) or 'LogE' metric, as stated by 'method'.
            % If 'SQ' is used, rescale can be used to modify the weights
            % associated to the quaternion interpolation (by default, the
            % rescale is 'kappa').
            % The mean can be "robust", i.e. only of the non-empty tensors
            % by setting 'robust' for opt.
            if nargin <4, opt = 'classic'; end
            if nargin<3, rescale = 'kappa'; opt = 'classic'; end
            if nargin<2, method = 'SQ';  end
            sz = size(di);
            if length(sz)>2
                error('[difftensor] Arrays must be 2D at most.');
            end
            if all(sz==1)
                % no avergaing needed
                d_mean = di;
            elseif any(sz==1)
                % simply average all element, row or column.
                l_nz = ~isempty(di);
                switch opt
                    case 'classic'
                        if all(l_nz)
                            d_mean = wmean(di(:),1/prod(sz),method,rescale);
                        else
                            d_mean = difftensor;
                        end
                    case 'robust'
                        if any(l_nz)
                            d_mean = wmean(di(l_nz),1/sum(l_nz),method,rescale);
                        else
                            d_mean = difftensor;
                        end
                    otherwise
                        error('[difftensor] Arrays must be of the same dimensions.');
                end
                
            else
                d_mean(1,sz(2)) = difftensor;
                l_nz = ~isempty(di);
                for ii=1:sz(2)
                    switch opt
                        case 'classic'
                            if all(l_nz(:,ii))
                                d_mean(ii) = wmean(di(:,ii),1/sz(1),method,rescale);
                            else
                                d_mean(ii) = difftensor;
                            end
                        case 'robust'
                            if any(l_nz(:,ii))
                                d_mean(ii) = wmean(di(l_nz(:,ii),ii),1/sum(l_nz(:,ii)),method,rescale);
                            else
                                d_mean(ii) = difftensor;
                            end
                        otherwise
                            error('[difftensor] Arrays must be of the same dimensions.');
                    end
                end;
            end
        end
        function [SdQ,k_dist_Q,dist_v] = anal_dist(d1,d2)

            % distance according to eigenvalues
            L1 = log(d1.EigValues);
            L2 = log(d2.EigValues);
            dist_v = sum((L2-L1).^2);
            % distance accroding to orientation, depending on k
            k = calck(d1.HA,d2.HA);
            if k<1e-4
                % no angular information
                SdQ = sqrt(dist_v);
            else
                % with angular information
                d2.setQ = getSetQ(d2.Orientation);
                dist_Q = realignD(d1.Orientation,d2.setQ);
                if dist_Q <1e-4
                    dist_Q = 0;
                end
                SdQ = k*sqrt(dist_Q) + sqrt(dist_v);
                k_dist_Q = k*sqrt(dist_Q);
                dist_v = sqrt(dist_v);
            end
            end
        function s = std(di,method,rescale)
            % s = std(di,method)
            %
            % Estimate the standard deviation (std) of an array of tensors
            % around its mean.
            % Should have about the same behviour as the 'std' operator on
            % an array of scalar, i.e. column wise std.
            
            if nargin<2, method = 'SQ'; rescale = 'kappa'; end
            if nargin <3, rescale = 'kappa'; end
            sz = size(di);
            if length(sz)>2
                error('[difftensor] Arrays must be 2D at most.');
            elseif all(sz<3)
                % no std possible
                s = [];
            elseif any(sz==1)
                % std of all element, row or column.
                % s = st_dev(di,method);
                dm = mean(di,method,rescale);
                D = dist(dm,di,method);
                s = sqrt(sum(D.^2))/prod(sz);
            else
                s = zeros(1,sz(2));
                for ii=1:sz(2)
                    % s(ii) = st_dev(di(:,ii),method);
                    dm = mean(di(:,ii),method);
                    D = dist(dm,di(:,ii),method);
                    s(ii) = sqrt(sum(D.^2))/prod(sz);
                end
            end
        end
        
    end
    
    
end

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% SUBFUNCTIONS : Utility functions
%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function q = mat2quat(V)
% Turning the eigenvectors into a quaternion

tr = trace(V);
r = sqrt(1+V(1,1)-V(2,2)-V(3,3));

if abs(tr+1)<1e-6 && r~=0
    q = mat2quat_2(V);
else
    theta = real(acos((tr-1)/2));
    if mod(theta,2*pi)~=0
        w = [V(3,2)-V(2,3) ; V(1,3)-V(3,1) ; V(2,1)-V(1,2)] ...
            / (2*sin(theta)) ;
    else
        w = zeros(3,1);
    end
    a = cos(theta/2);
    V = w*sin(theta/2);
    
    q = [a ; V];
    q = q/norm(q);
end
end

function q = mat2quat_2(V)
% Other way of turning the eigenvectors into a quaternion
r = sqrt(1+V(1,1)-V(2,2)-V(3,3));
% if r==0
%   q= mat2quat(V);
% else
q = zeros(4,1);
q(1) = (V(3,2)-V(2,3))/(2*r);

q(2) = r/2;
q(3) = (V(1,2)+V(2,1))/(2*r);
q(4) = (V(3,1)+V(1,3))/(2*r);
end

function q2n = realignQ(q1,Q2)
% Realigning quaternion_2 (single q or set of 8 orients) on quaternion_1
if size(Q2,2)==1
    Q2 = getSetQ(Q2);
end
a = q1'*Q2;
[~,I_N] = max(a);
q2n = Q2(:,I_N);
end

function qm = multiplication(q1,q2)
% Multiplying 2 quaternions
qm = zeros(4,1);
qm(1) = q1'*[q2(1); -q2(2); -q2(3); -q2(4)];
qm(2) = q1(1)*q2(2)+ q2(1)*q1(2)+ q1(3)*q2(4)-q1(4)*q2(3);
qm(3) = q1(1)*q2(3)+ q2(1)*q1(3)+ q1(4)*q2(2)-q1(2)*q2(4);
qm(4) = q1(1)*q2(4)+q2(1)*q1(4)+ q1(2)*q2(3)-q1(3)*q2(2);
end

function R = quat2mat(q)
% Turning a quaternion into a rotation matrix/eigenvectors
a = q(1);
V = q(2:4);
theta = 2*acos(a);

if theta==0
    w = [0 0 0];
else
    w = V/sin(theta/2);
end

w_hat = [0 -w(3) w(2); w(3) 0 -w(1); -w(2) w(1) 0];
R = expm(w_hat*theta);
% R = Rexpm(w_hat*theta);
end

function di = realignD(q1,Q2)
% Distance between set of quaternions.
a  = q1'*Q2;
di = max(a);
di = 2-2*di;
end

function Q = getSetQ(q)
% Get 8 permutations of quaternion
Q = [q(1) -q(1)   q(2) -q(2)   q(3) -q(3)  q(4) -q(4) ;
    q(2) -q(2)  -q(1)  q(1)   q(4) -q(4) -q(3)  q(3) ;
    q(3) -q(3)  -q(4)  q(4)  -q(1)  q(1)  q(2) -q(2) ;
    q(4) -q(4)   q(3) -q(3)  -q(2)  q(2) -q(1)  q(1) ];
end

function RA = calcRA(v)
% Calculate RA
lambdam = sum(v)/3;
RA = sqrt(sum((v-lambdam*ones(3,1)).^2)) / lambdam / sqrt(6);
end

function FA = calcFA(v)
% Calculate FA
lambdam = sum(v)/3;
FA = sqrt(3/2) * sqrt(sum( (v-lambdam).^2 )) / sqrt(sum(v.^2));
end

function HA = calcHA(v)
% Calculate HA

% Check the ordering of the eigenvalues
v = sort(v,'descend');
HA = log(v(1)/v(3));

end

function dLE = dist_LE(d1,d2)
% calculate Log-Euclidian distance between 2 tensors
R1 = d1.EigVectors;
R2 = d2.EigVectors;
L1 = R1*diag(log(d1.EigValues))*R1';
L2 = R2*diag(log(d2.EigValues))*R2';
A  = L1 - L2;
dLE = sqrt(trace(A'*A));
end

function SdQ = dist_SQ(d1,d2)
% calculate SQ distance between 2 tensors

% distance according to eigenvalues
L1 = log(d1.EigValues);
L2 = log(d2.EigValues);
dist_v = sum((L2-L1).^2);
% distance accroding to orientation, depending on k
k = calck(d1.HA,d2.HA);
if k<1e-4
    % no angular information
    SdQ = sqrt(dist_v);
else
    % with angular information
    d2.setQ = getSetQ(d2.Orientation);
    dist_Q = realignD(d1.Orientation,d2.setQ);
    if dist_Q <1e-4
        dist_Q = 0;
    end
    SdQ = k*sqrt(dist_Q) + sqrt(dist_v);
end
end

function [k,dist_Q,rq] = grad_q(d1,d2)
% k
k = calck(d1.HA,d2.HA);
% distance accroding to orientation
dist_Q = realignD(d1.Orientation,d2.setQ);
% realigned quaternion
rq = realignQ(d1.Orientation,d2.setQ);
    
end

function k = calck(HA1,HA2)
% weighting of eigenvector distance
d1= size(HA1);
d2= size(HA2);
alpha = 0.6;
if prod(d1)~= prod(d2) && prod(d2) == 1
k = zeros(prod(d1),1);
for ii=1 : prod(d1)
xB = alpha*min(HA1(ii),HA2);
k(ii) = xB^4/(1+xB^4);
end

elseif prod(d1)==prod(d2)
    k = zeros(prod(d1),1);
for ii=1 : prod(d1)
xB = alpha*min(HA1(ii),HA2(ii));
k(ii) = xB^4/(1+xB^4);
end

else error('[difftensor] Problem of dimension to compute k');
end
end

function S = Sexpm(L)
% matrix exponential
[v,d] = eig(L);
S = v*diag(exp(diag(d)))*v';
end

% function Re = Rexpm(G)
% % G must be anti-symmetric
% g = [G(3,2) G(1,3) G(2,1)]';
% w = g/norm(G);
% what = [0 -w(3) w(2); w(3) 0 -w(1);-w(2) w(1) 0];
% theta = G(1,2)/what(1,2);
% Re = eye(3)+ what*sin(theta)+ what^2*(1-cos(theta));
% end

function c = vectprod(a,b)
% vectorial product of 2 vectors
% http://en.wikipedia.org/wiki/Cross_product#Coordinate_notation
c = [...
    a(2)*b(3)-a(3)*b(2) ; ...
    a(3)*b(1)-a(1)*b(3) ; ...
    a(1)*b(2)-a(2)*b(1) ];
end

function Ro = buildrot(r,theta)
% build rotation matricx from axis and angle
% http://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
tmp = [0 -r(3) r(2) ; r(3) 0 -r(1) ; -r(2) r(1) 0];
Ro = eye(3)*cos(theta) + sin(theta)*tmp + (1-cos(theta)) * (r*r');
end

