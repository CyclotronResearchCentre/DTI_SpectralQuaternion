classdef difftensor
    % DIFFTENSOR
    %
    % "Diffusion tensor" class definition and operators
    % overloading/definition.
    %
    % MAIN:
    %======
    % D = difftensor(F)
    % A tensor object can be generated by passing F as
    % - a 3x3 (tensor) matrix
    % - a cell array of 3x3 (tensor) matrices or 6 cell arrays (one per
    %   component of the tensor) or N-D matrices.
    % - a 4D/3D/2D array (Nx x Ny x Nz x 6) with tensor's 6 components 
    %   (xx, xy,xz, yy, yz, zz). The last dimension should always be of 
    %   size 6!
    %
    % Options:
    % - ordering of the components.
    %   when passing 6 components, the default order is F = [Dxx Dxy Dxz  
    %   Dyy Dyz Dzz], i.e. "column-wise". An extra 'order' argument can be  
    %   passed to accommodate other ordering of the components. E.g. with a
    %   "diagonal-wise" ordering F = [Dxx Dyy Dzz Dxy Dyz Dxz], use 
    %   order = [1 4 6 2 5 3] and D = difftensor(F,order)
    % - eigenvalues>0
    %   you can force to take the absolute value of the eigenvalues of the
    %   3x3 passed (or created from the 6 components) to ensure it is
    %   positive demi-definite, by passing an extra char argument 'abs'.
    %   E.g. D = difftensor(F,'abs') or D = difftensor(F,order,'abs')
    % 
    % NOTES:
    %=======
    % - Tensors are built one by one, even when passing (cell) arrays, this
    %   may take a bit of time if the array is very large.
    % - If any eigenvalue is <0 then the returned tensor is left empty 
    %   (with a warning)! To avoid empty tensors, use the 'abs' option.
    % - Tensor can be organised in arrays of "any" size. 2D/3D arrays
    %   should be ok.
    %
    % Each tensor is defined internally only by its:
    %   - eigenvalues (EigValues), sorted in descending order
    %   - orientation (Orientation), expressed as a quaternion
    %   - eigenvectors (EigVectors), this is redundant but efficient for
    %       logE calculation
    %
    % METHODS:
    %=========
    %   difftensor    - building of the tensor (array)
    %   getDet        - get determinant(s)
    %   getFA         - get the FA value(s) -> output with same array size
    %   getRA         - get the RA value(s) -> output with same array size
    %   getHA         - get the HA value(s) -> output with same array size
    %   getTensor     - get the rebuilt tensor(s), in a cell array of 
    %                   tensors (use the 'cll' option, Def.) or 'Size x 6'
    %                   array (use the 'img' option).
    %   get1stEVec    - get the 1st eigenvector (main tensor direction), in
    %                   a 'Size x 3' array 
    %   getEVal       - get the eigenvalues, in a 'Size x 3' array 
    %   getTr         - get the trace(s)
    %   dist          - distance between 2 tensors, with SQ or LogE metric
    %   wmean         - weighter mean of all array elements
    %   mean          - mean of tensors, overloading Matlab 'mean' function
    %   std           - standard deviation of distance around mean tensor,
    %                   similar to Matlab 'std' function.
    %   rotate        - rotate tensor(s), with either rot matrix R or
    %                   quaternion q (or celle array thereof).
    %   scale         - rescale tensor(s)
    %   isempty       - overloaded function for difftensor
    %   text_display  - display as text
    %   graph_display - display graphically (up to 3D arrays) as ellipses
    %   vect_display  - display the main vector, weighted by the FA
    %
    % REFERENCE:
    %===========
    % More information about the SQ methods (distance, mean) are available
    % in
    %
    %   A. Collard, S.Bonnabel, C. Phillips and R. Sepulchre, 'Anisotropy
    %   preserving DTI processing', International Journal of Computer
    %   Vision, 2014, 107:58-74.
	%   http://link.springer.com/article/10.1007/s11263-013-0674-4
    % 
    % For the latest developments check the public repository:
    %
    %   https://github.com/CyclotronResearchCentre/DTI_SpectralQuaternion
    %______________________________________________________________________
    % Copyright (C) 2014 University of Liege, Belgium
    
    % Written by A. Collard & C. Phillips, 2014.
    % Department of Electrical Engineering and Computer Science &
    % Cyclotron Research Centre, University of Liege, Belgium
    % Contact: c.phillips@ulg.ac.be
    
    % CP NOTES:
    % Stuff to check or fix in the code!
    % 1/ Why 2 rotate functions? Should we pool them together? That would  
    % be less confusing/eaiser to use.
    % -> DONE
    % 2/ Should we include the 'abs' function? -> ensures the eigenvalues 
    % are positive, instead of including this in the building function.
    % REP: probably not a good idea after all but this can be discussed...
    % 3/ Why a getHA that recalculates HA? Couldn't just extract it from the
    % object as it's built in?
    % -> DONE

    %% PROPERTIES
    %%
    properties
        EigValues   % eigenvalues, sorted in descending order
        Orientation % eigenvectors, expressed as a quaternion
        EigVectors  % eigenvectors (this is redundant but more efficient
                    % for logE calculation)
    end
    
    properties (SetAccess = private)
        HA      % Hibert anisotropy value
        setQ    % 8 sets of quaternion permutations
    end
    
    methods
        %% OBJECT DEFINITION: set tensor, eigenvalues & orientation
        %%
        
        function d = difftensor(F,varargin)
            % Allow nargin == 0 syntax
            if nargin ~=0 && ~iscell(F)
                % Input as numerical array in various format: 4D/3D/2D 
                % array (Nx x Ny x Nz x 6) with tensor's 6 components
                if ~isnumeric(F)
                    error('difftensor:input', ...
                            '[difftensor] The diffusion tensor must be a 3x3 matrix.');
                end
                if ndims(F)==2 && all(size(F)==[3 3])
                    % 3x3 array -> Basic case, used by all the others to
                    % build each tensor element!
                    %
                    % Take the absolute value of eigenvalues if requested.
                    if nargin==1
                        aEigVal = false;
                    else
                        if ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                        else
                            aEigVal = logical(varargin{1});
                        end
                    end
                    % Build tensor
                    [V,E] = eig(F);
                    dE = diag(E);
                    if aEigVal, dE = abs(dE); end
                    if sum(sign(dE))<3
                        warning('difftensor:eigval', ...
                            '[difftensor] The diffusion tensor must be positive.');
                        d = difftensor; % returning empty tensor
                        return
                    end
                    [dE, I] = sort(dE,'descend');
                    d.EigValues = dE;
                    V = det(V)*V;
                    V1 = [V(:,I(1)) V(:,I(2)) V(:,I(3))];
                    V1 = V1*det(V1);
                    q1 = mat2quat(V1);
                    d.EigVectors = V1;
                    d.Orientation = q1;
                    d.HA = calcHA(d.EigValues);
                    d.setQ = getSetQ(q1);
                    
                elseif  (ndims(F)==4 && size(F,4)==6) || ...
                        (ndims(F)==3 && size(F,3)==6) || ...
                        (ndims(F)==2 && length(F)==6)
                    % 4D/3D/2D array Nx (x Ny) (x Nz) x 6 array,
                    % as in 3D/2D/1D x 6 images
                    % The last dimension should always be of size 6!
                    
                    % Handle special cases: 
                    %   - different ordering of components and,
                    %   - taking the abs-value of eigen values or not.
                    if nargin==1
                        order = [1 2 3 4 5 6];
                        % for [Dxx Dxy Dxz Dyy Dyz Dzz] by default
                        aEigVal = false;
                    elseif nargin==2
                        if isnumeric(varargin{1})
                            order = varargin{1};
                            % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                            if numel(order)~=6
                                warning('difftensor:order',...
                                    '[difftensor] Wrong ''order'' size, using default.');
                                order = [1 2 3 4 5 6];
                            end
                            aEigVal = false;
                        elseif ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                            order = [1 2 3 4 5 6];
                        else
                            error('difftensor:input', ...
                                '[difftensor] Wrong input to create tensor (array).');
                        end
                    elseif nargin==3
                        order = varargin{1};
                        % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                        if numel(order)~=6
                            warning('difftensor:order', ...
                                '[difftensor] Wrong ''order'' size, using default.');
                            order = [1 2 3 4 5 6];
                        end
                        if strcmpi(varargin{2},'abs')
                            aEigVal = true;
                        else
                            aEigVal = false;
                        end
                    else
                        error('difftensor:input', ...
                            '[difftensor] Wrong input to create tensor (array).');
                    end
                    
                    sz = size(F);
                    % Special case of 6 elements as a 6x1 vector
                    if ndims(F)==2 && sz(1)==6 && sz(2)==1
                        F = F';
                        sz = size(F);
                    end
                    
                    % Create tensor array
                    F = reshape(F,prod(sz(1:end-1)),6)'; % 6 x Ntensor array
                    d(prod(sz(1:end-1))) = difftensor; % allocate object array
                    for ii = 1:prod(sz(1:end-1))
                        tF = F(order,ii);
                        tmp = [ tF(1) tF(2) tF(3) ; ...
                                tF(2) tF(4) tF(5) ; ...
                                tF(3) tF(5) tF(6) ];
                        d(ii) = difftensor(tmp,aEigVal);
                    end
                    if length(sz)>2 % 3D/2D array only
                        d = reshape(d,sz(1:end-1));
                    end
                else
                    error('difftensor:input', ...
                        '[difftensor] Unknown input format.');
                end
                
            elseif nargin ~= 0 && iscell(F)
                % Cell array input -> 2 possibilities:
                % - 6 cells array, with 1 tensor component [n m] array
                % - [n m] cell array, with 1 tensor per element 
                if ndims(F)==2 && length(F)==6 %#ok<*ISMAT>
                    % Input as 6 cell arrays with the 6 tensor elements
                    
                    % Handle special cases: different ordering of
                    % components and taking the abs-value of eigen values.
                    if nargin==1
                        order = [1 2 3 4 5 6];
                        % for [Dxx Dxy Dxz Dyy Dyz Dzz] by default
                        aEigVal = false;
                    elseif nargin==2
                        if isnumeric(varargin{1})
                            order = varargin{1};
                            % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                            if numel(order)~=6
                                warning('difftensor:order', ...
                                    '[difftensor] Wrong ''order'' size, using default.'); %#ok<*WNTAG>
                                order = [1 2 3 4 5 6];
                            end
                            aEigVal = false;
                        elseif ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                            order = [1 2 3 4 5 6];
                        else
                            error('[difftensor] Wrong input to create tensor (array).');
                        end
                    elseif nargin==3
                        order = varargin{1};
                        % e.g. [1 4 6 2 5 3] for [Dxx Dyy Dzz Dxy Dyz Dxz]
                        if numel(order)~=6
                            warning('difftensor:order', ...
                                '[difftensor] Wrong ''order'' size, using default.');
                            order = [1 2 3 4 5 6];
                        end
                        if strcmpi(varargin{2},'abs')
                            aEigVal = true;
                        else
                            aEigVal = false;
                        end
                    else
                        error('difftensor:input', ...
                            '[difftensor] Wrong input to create tensor (array).');
                    end
                    
                    % Build tensor array
                    sz = size(F{1});
                    d(prod(sz)) = difftensor; % Preallocate object array
                    for ii = 1:prod(sz)
                        tmp = [ ...
                            F{order(1)}(ii) F{order(2)}(ii) F{order(3)}(ii) ; ...
                            F{order(2)}(ii) F{order(4)}(ii) F{order(5)}(ii) ; ...
                            F{order(3)}(ii) F{order(5)}(ii) F{order(6)}(ii) ];
                        d(ii) = difftensor(tmp,aEigVal);
                    end
                    d = reshape(d,sz);
                else
                    % Input as cell array, each cell being a 3x3 array
                    if nargin==1
                        aEigVal = false;
                    elseif nargin==2
                        if ischar(varargin{1})
                            if strcmpi(varargin{1},'abs')
                                aEigVal = true;
                            else
                                aEigVal = false;
                            end
                        
                        else
                            error('[difftensor] Wrong input to create tensor (array).');
                        end
                    end
                    sz = size(F); % allow any cell-array size
                    d(prod(sz)) = difftensor; % Preallocate object array
                    for ii = 1:prod(sz)
                        d(ii) = difftensor(F{ii},aEigVal);
                    end
                    d = reshape(d,sz);
                end
                
            end
        end
        
        function obj = set.EigValues(obj,value)
            % Eigenvalues are sorted in descending order.
            % Their positiveness is checked!
            if sum(sign(value))<3 || numel(value)~=3
                display(value);
                error('difftensor:eigval', ...
                    '[difftensor] The diffusion tensor must be positive.');
            end
            value = sort(value,'descend');
            obj.EigValues = value(:);
        end
        
        function obj = set.Orientation(obj,value)
            % The dimension and norm of the quaternion are checked.
            if abs(norm(value)-1)>10e-5 || numel(value)~=4
                error('difftensor:quaternion', ...
                    '[difftensor] Orientation must be given by a unit quaternion.');
            end
            obj.Orientation = value(:);
        end
        
        function obj = set.EigVectors(obj,value)
            % The dimension and norm of the rotation matrix are checked.
            if numel(value)==4 && abs(norm(value)-1)<10e-5
                % if quaternion passed.
                value = quat2mat(value);
            end
            if abs(det(value)-1)>10e-5 || numel(value)~=9
                error('difftensor:eigvect', ...
                    '[difftensor] Eigenvectors must be given by a rotation matrix.');
            end
            obj.EigVectors = value(:,:);
        end
        
        function obj = set.HA(obj,value)
            % HA set method
            obj.HA = value;
        end
        
        function obj = set.setQ(obj,value)
            % setQ set method
            if numel(value)==4
                obj.setQ = getSetQ(value);
            else
                obj.setQ = value;
            end
        end
        
        %% OBJECT METHODS: overloading some simple functions
        %%
        
        function out = isempty(obj)
            % check for empty tensor
            sz = size(obj);
            out = zeros(sz);
            for ii=1:prod(sz)
                out(ii) = isempty(obj(ii).EigValues);
            end
        end
        
        %% OBJECT METHODS: get tensor, determinant, trace, RA, FA,
        %%                 1st EigVector
        %%
        
        function T = getTensor(obj,opt)
            % get the (rebuilt) tensors
            if nargin<2, opt = 'cll'; end
            sz = size(obj);
            if prod(sz)==1
                if ~isempty(obj)
                    R = quat2mat(obj.Orientation);
                    T = R*diag(obj.EigValues)*R';
                else
                    T = [];
                end
            else
                switch opt
                    case 'cll'
                        % Output as cell array of tensors
                        T = cell(sz);
                        for ii=1:prod(sz);
                            if ~isempty(obj(ii))
                                R = quat2mat(obj(ii).Orientation);
                                T{ii} = R*diag(obj(ii).EigValues)*R';
                            else
                                T{ii} = [];
                            end
                        end
                    case 'img'
                        % Output as 'image' component (sz x 6)
                        T = zeros(prod(sz),6);
                        for ii=1:prod(sz);
                            if ~isempty(obj(ii))
                                R = quat2mat(obj(ii).Orientation);
                                tmp = R*diag(obj(ii).EigValues)*R';
                                T(ii,:) = [tmp(1) tmp(2) tmp(3) ...
                                    tmp(5) tmp(6) tmp(9)];
                            end
                        end
                        T = reshape(T,[sz, 6]);
                end
            end
        end
        
        function EV1 = get1stEVec(obj)
            % Get the 1st eigenvector
            sz = size(obj);
            EV1 = zeros([prod(sz),3]);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    EV1(ii,:) = obj(ii).EigVectors(:,1)';
                end
            end
            if prod(sz)>1
                EV1 = reshape(EV1,[sz 3]);
            else
                EV1 = EV1';
            end
        end
        
        function EVal = getEVal(obj)
            % Get the eigenvalues
            sz = size(obj);
            EVal = zeros([prod(sz),3]);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    EVal(ii,:) = obj(ii).EigValues;
                end
            end
            if prod(sz)>1
                EVal = reshape(EVal,[sz 3]);
%             else
%                 EV1 = EV1';
            end
        end
        
        function dete = getDet(obj)
            % Det get method
            sz = size(obj);
            dete = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    dete(ii) = prod(obj(ii).EigValues);
                end
            end
        end
        
        function tr = getTr(obj)
            % trace get method
            sz = size(obj);
            tr = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    tr(ii) = sum(obj(ii).EigValues);
                end
            end
        end
        
        function RA = getRA(obj)
            % RA get method
            sz = size(obj);
            RA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    RA(ii) = calcRA(obj(ii).EigValues);
                end
            end
        end
        
        function FA = getFA(obj)
            % FA get method
            sz = size(obj);
            FA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    FA(ii) = calcFA(obj(ii).EigValues);
                end
            end
        end
        
        function HA = getHA(obj)
            % HA get method
            sz = size(obj);
            HA = zeros(sz);
            for ii=1:prod(sz)
                if ~isempty(obj(ii))
                    HA(ii) = obj(ii).HA;
                end
            end
        end
               
        %% OBJECT METHODS: apply rotation, affine & scale
        %%

        function dr = rotate(d,R)
            % Rotate d by rot matrix R (3x3 matrix) or quaternion q (4x1).
            % - if R is a single rot matrix/quaternion 
            %       -> apply on all elements of d one by one
            % - if R is a cell-array of rot matrices/quaternions and it has
            %   the same size as d -> apply rotation element by element
            
            dr = d;
            if isnumeric(R)
                % apply same rotation matrix to all tensors
                if all(size(R)==[3 3]) 
                    if abs(det(R)-1)>1e-10
                        display(R)
                        error('difftensor:rotate', ...
                            '[difftensor] R must be a rotation matrix');
                    else
                        qR = mat2quat(R);
                    end
                elseif all(size(R)==[4 1]) 
                    if abs(norm(R)-1)>1e-10
                        error('difftensor:rotate', ...
                            '[difftensor] qR must be a unit quaternion');
                    else
                        qR = R;
                    end
                else
                    error('difftensor:rotate', ...
                        '[difftensor] Invalid rotation operation.');
                end
                QR = [qR -qR];
                for ii=1:numel(d)
                    qR_R = realignQ(d(ii).Orientation,QR);
                    qnew = multiplication(qR_R,d(ii).Orientation);
                    dr(ii).Orientation = qnew;
                    dr(ii).EigVectors = quat2mat(qnew);
                end                
            elseif iscell(R) && all(size(d)==size(R))
                % apply rotation element by element
                for ii=1:numel(d)
                    dr(ii) = rotate(d(ii),R{ii}); % Use simple case 
                end
            else
                error('difftensor:rotate', ...
                    '[difftensor] Invalid rotation operation.');
            end
        end
       
        function ds = scale(d,S)
            % Scale d by S
            % - if S is a single scalar
            %       -> apply the same scaling to all eigenvalues
            % - if S is a 3x1 vector
            %       -> all the scaling on each eigenvalues of all elements
            % - if S is a scalar-array of scaling factor and d is a
            %   difftensor array of the same size as S
            %       -> apply scaling on 3 eigenvalues element by element
            % - if S is a cell-array of scaling (3x1) vectors and d is a
            %   difftensor array of the same size as S
            %       -> apply scaling eigenvalue by eigenvalue and element
            %          by element
            
            ds = d;
            if isnumeric(S)
                if any(S<=0)
                    error('difftensor:scale', ...
                            '[difftensor] Scaling must be positive.');
                end
                if numel(S)==1 || numel(S)==3
                    % apply same scaling to all array elements
                    for ii=1:numel(d)
                        if ~isempty(d(ii))
                            ds(ii).EigValues = S(:).*d(ii).EigValues;
                        end
                    end
                elseif all(size(d)==size(S))
                    % apply same scaling on all eigen values, element by element
                    for ii=1:numel(d)
                        if ~isempty(d(ii))
                            ds(ii).EigValues = S(ii)*d(ii).EigValues;
                        end
                    end
                else
                    error('difftensor:scale', ...
                            '[difftensor] Invalid scaling operation.');
                end
            elseif iscell(S) && all(size(d)==size(S))
                % apply 3x1 scaling element by element
                for ii=1:numel(d)
                    if any(S{ii}<0) || numel(S{ii})~=3
                        error('difftensor:scale', ...
                            '[difftensor] Invalid scaling operation.');
                    end
                    if ~isempty(d(ii))
                        ds(ii).EigValues = S{ii}(:).*d(ii).EigValues;
                    end
                end
                
            else
                error('difftensor:scale', ...
                            '[difftensor] Invalid scaling operation.');
            end
        end
        
        %% OBJECT METHODS: display functions (text & plot)
        %%

        function text_display(d)
            % Rebuild the tensor and 'print' it
            for ii=1:numel(d)
                display(getTensor(d(ii)));
            end
        end
        
        function vect_display(d)
            % vect_display(d)
            %
            % Plot the 1st eigenvector of the tensor as a small line:
            % - the length is proportional to FA
            % - color is the RGB of the 1st eigenvector
            %
            % Note:
            % There is room for improvements here. For example: 
            % - choice of the scaling by RA, FA or HA
            % - control of the line size
            
            sz = size(d);
            if numel(sz)>3,
                error('difftensor:vect_display', ...
                    '[difftensor] Can only display up to 3D tensor array');
            elseif numel(sz)==2
                sz(3) = 1;
            elseif numel(sz)==1
                sz(2) = 1; sz(3) = 1;
            end
            figure
            hold on
            for ii=1:sz(1)
                for jj=1:sz(2)
                    for kk=1:sz(3)
                        if ~isempty(d(ii,jj,kk))
                            v = d(ii,jj,kk).EigVectors(:,1);
                            vw = v*getFA(d(ii,jj,kk))/2;
                            x = (jj-1);
                            y = (ii-1);
                            z = (kk-1);
                            plot3([x+vw(1) x-vw(1)]',[y+vw(2) y-vw(2)]',...
                                [z+vw(3) z-vw(3)],'Color',abs(v)','LineWidth',2)
                            plot3(x,y,z,'ko')
                        end
                    end
                end
            end
            axis image, axis xy
            light, lighting gouraud
            view(3), rotate3d on
            xlabel('axis i'), ylabel('axis j'), zlabel('axis k')
        end
        
        function graph_display(d,s,typecol)
            % graph_display(d,s,typecol)
            %
            % Can plot single tensor or array of tensors, up to 3D, as
            % ellipsoids. These can be scaled by a scalar (s).
            n  = 20;
            xc = 0; yc = 0; zc = 0;
            sz = size(d);
            if nargin<2,
                tmp = getEVal(d);
                M_ev = max(tmp,[],numel(sz)+1);
                s = 1/sqrt(max(M_ev(:)));
                typecol = 'Dircol';
            elseif isempty(s)
                s = 1;
            elseif s<0
                M_ev = maxEV(d);
                s = -s*1/sqrt(max(M_ev(:)));
            elseif nargin<3
                typecol = 'Dircol';
            end
            
            if numel(sz)>3,
                error('difftensor:graph_disp', ...
                    '[difftensor] Can only display up to 3D tensor array');
            elseif numel(sz)==2
                sz(3) = 1;
            elseif numel(sz)==1
                sz(2) = 1; sz(3) = 1;
            end
           
            maxHA = max(max(getHA(d)));
            minHA = min(min(getHA(d)));
            figure
            hold on
            for ii=1:sz(1)
                for jj=1:sz(2)
                    for kk=1:sz(3)
                        B  = s*(sqrt(d(ii,jj,kk).EigValues));
                        if ~isempty(B)
                            xr = B(1)/2;
                            yr = B(2)/2;
                            zr = B(3)/2;
                            [x,y,z] = ellipsoid(xc,yc,zc,xr,yr,zr,n);
                            
                            % Transformer V
                            Q = d(ii,jj,kk).EigVectors;
                            if isempty(Q)
                                q = d(ii,jj,kk).Orientation;
                                Q = quat2mat(q);
                            end
                            if isnan(Q)
                                display(ii);
                                display(jj);
                                display(d(ii,jj,kk).Orientation);
                            end
                            for i=1:n+1
                                for j=1:n+1
                                    a = [x(i,j) y(i,j) z(i,j)]';
                                    A = Q*a;
                                    x(i,j) = A(1);
                                    y(i,j) = A(2);
                                    z(i,j) = A(3);
                                end
                            end
                            x = x+(jj-1);
                            y = y+(ii-1);
                            z = z+(kk-1);
                            if strcmpi(typecol,'Dircol')
                                 T = Q*diag(B)*Q';
                                 col = abs(diag(T));
                                 col = col/max(col);
                            else 
                                if abs(maxHA-minHA)>1e-5
                                    xcol= 1 - ( (d(ii,jj,kk).HA-minHA) / ...
                                        (maxHA-minHA) );
%                                     xcol= 1-((getHA(d(ii,jj,kk))-minHA)/(maxHA-minHA));
                                else
                                    xcol= 0;
                                end
                            col= [1 xcol 0];
                            end
                            
%                             if col(1)==col(2) && col(2)==col(3)
%                                 col = zeros(3,1);
%                             end
                            surf(x,y,z,'EdgeColor','none','FaceColor',col);
                        end
                    end
                end
            end
            axis image, axis xy
            light, lighting gouraud
            view(3), rotate3d on
            xlabel('axis i'), ylabel('axis j'), zlabel('axis k')
        end
        
        %% OBJECT METHODS: distance, (weighted) averaging & std.
        %%

        function di = dist(d1,d2,method)
            % di = dist(d1,d2,method)
            %
            % Distance between tensors, passed as 2 arguments:
            % - if d1 & d2 are tensors, distance between the 2
            % - if arrays of same size, distance element by element
            % - if d1=tensor & d2=tensor_array, distance between 1 and all
            %
            % Distance can be computed by "log-Euclidian" metric or
            % "SQ decomposition". Specified in 3rd argument by 'SQ' 
            % or 'LogE'. By default, distance is 'SQ'.
            
            if nargin<3
                method = 'SQ';
            end
            
            if numel(d1)==1 && numel(d2)==1
                sz = 1;
                one_vs_others = true;
            elseif numel(d1)==1 && numel(d2)>1
                sz = size(d2);
                one_vs_others = true;
            elseif numel(d1)>1 && numel(d1)==numel(d2)
                % check array size
                sz = size(d1);
                if ~all(sz == size(d2))
                    error('difftensor:dist', ...
                        '[difftensor] Invalid tensor array size for distance.');
                end
                one_vs_others = false;
            else
                error('difftensor:dist', ...
                    '[difftensor] Invalid input for tensor distance.');
            end
            
            % initialize output
            di = zeros(sz);
            
            % loop through all elements
            for ii=1:prod(sz)
                if one_vs_others
                    dt1 = d1;
                    dt2 = d2(ii);
                else
                    dt1 = d1(ii);
                    dt2 = d2(ii);
                end
                switch method
                    % switch between distance metrics
                    case 'SQ'
                        di(ii) = dist_SQ(dt1,dt2);
                    case 'LogE'
                        di(ii) = dist_LE(dt1,dt2);
                    otherwise
                        error('difftensor:dist', ...
                            '[difftensor] Unknown distance method.');
                end
            end
        end
        
        function d_mean = wmean(di,w,method,rescale)
            % d_mean = wmean(di,w,method,rescale)
            %
            % Average between all tensors, using the 'SQ' or 'LogE' metric.
            % A weighted mean is possible, depending on the value of w.
            % If using SQ, rescale enables to modify the weights for the 
            % quaternion interpolation.
            % - 'kappa' : the weights are computed following Eq. (40) of 
            %   the reference paper by Collard et al.
            % - 'no' : no rescaling is used, weights w are used.
            % - 'HA' : the weights are multiplied by the anisotropy of the
            %   tensor (and then normalized).
            %
            % By default, 
            % - w = 1/#tensors,
            % - rescale is 'kappa', and
            % - method is 'SQ'.
            
            % Default method            
            if nargin<4
                rescale = 'kappa';
            end
            if nargin<3
                method = 'SQ';
            end
            % Prepare input
            if numel(di)==1
                d_mean = di;
                return
            else
                num_dt = numel(di);
            end
            if nargin<2
                w = ones(num_dt,1)/num_dt;
            elseif any(w<0)
                error('difftensor:wmean', ...
                    '[difftensor] All weights should be >0');                
            elseif numel(w)==1
                w = ones(num_dt,1)*w;
            elseif size(w,1)==1
                w = w';
            elseif numel(w)~=num_dt
                error('difftensor:wmean', ...
                    '[difftensor] Incorrect number of weights');
            end
            % Ensure sum of weights = 1
            w = w/sum(w);
            
            A = find(w==1); 
            if ~isempty(A)
                d_mean = di(A);
            else
                switch method
                    case 'SQ'
                        E = zeros(3,1);
                        for ii=1:num_dt
                            E = E + w(ii)*log(di(ii).EigValues);
                        end
                        Eval_m = exp(E);
                        HAm = calcHA(Eval_m);
                        HAi= getHA(di);
%                         HAi= di.HA;
                        % display(HAi);
                        % k parameters
                        if strcmp(rescale,'kappa')
                            k = calck(HAi(:),HAm);
%                           display(k(:))
                        elseif strcmp(rescale,'no')
                            k = ones(num_dt,1);
                        elseif strcmp(rescale,'HA')
                            if HAm~=0
                                k = HAi(:)/HAm;
                            else 
                                k = zeros(num_dt,1);
                            end
                        end
%                         display(k(:));
                        sk = sum(k);
                        if sk == 0
                            kw = w;
                            sk = sum(kw);
                        else
                            kw = w .* k;
                            sk = sum(kw);
%                         display(kw/sk)
                        end
%                         display(kw./sk);
                        % find reference tensor/quaternion
                        [~,Iwmax] = max(kw);
                        qr = di(Iwmax).Orientation;
                        qm = qr*kw(Iwmax)/sk;
                        % find other realigned quaternions, 
                        % and compute the mean
                        for ii=1:num_dt
                            if ii~=Iwmax
                                Q2  = di(ii).setQ;
                                if isempty(Q2)
                                    Q2 = getSetQ(di(ii).Orientation);
                                end
                                q2n = realignQ(qr,Q2);
                                qm  = qm + kw(ii)*q2n/sk;
                            end
                        end
                        qm = qm/norm(qm);
%                         if isnan(qm)
%                             display(qm);
%                             display(w);
%                             display(k)
%                             display(kw);
%                             display(qr);
%                             display(HAi(:));
%                             display(HAm);
%                        end
                        d_mean = difftensor;
                        d_mean.EigValues = Eval_m;
                        d_mean.Orientation = qm;
                        d_mean.EigVectors = quat2mat(qm);
                          % display(d_mean.HA);
                        d_mean.HA = HAm;
                        d_mean.setQ = getSetQ(qm);
                    
                    case 'LogE'
                        Lt = zeros(3,3);
                        for ii=1:num_dt
                            R = di(ii).EigVectors;
                            if isempty(R)
                                R = quat2mat(di(ii).Orientation);
                            end
                            Ln = R*diag(log(di(ii).EigValues))*R';
                            Lt = Lt + w(ii)*Ln;
                        end
                        d_mean = difftensor(Sexpm(Lt));
                    
                    otherwise
                        error('[difftensor] Unknow tensor metric');
                end
            end
        end
        
        function d_mean = mean(di,method,rescale,opt)
            % d_mean = mean(di,method,rescale,opt)
            %
            % Estimate the mean of a 2D array of tensors.
            % Should have about the same behaviour as the 'mean' operator 
            % on an array of scalar, i.e. column wise mean.
            % Using the 'SQ'(def.) or 'LogE' metric, as stated by 'method'.
            % If 'SQ' is used, rescale can be used to modify the weights
            % associated to the quaternion interpolation (by default, the
            % rescale is 'kappa').
            % The mean can be "robust", i.e. only of the non-empty tensors
            % by setting 'robust' for opt.
            if nargin<4, opt = 'classic'; end
            if nargin<3, rescale = 'kappa'; end
            if nargin<2, method = 'SQ';  end
            sz = size(di);
            if length(sz)>2
                error('difftensor:mean', ...
                    '[difftensor] Arrays must be 2D at most.');
            end
            if all(sz==1)
                % no avergaing needed
                d_mean = di;
            elseif any(sz==1)
                % simply average all element, row or column.
                l_nz = ~isempty(di);
                switch opt
                    case 'classic'
                        if all(l_nz)
                            d_mean = wmean(di(:),1/prod(sz),method,rescale);
                        else
                            d_mean = difftensor;
                        end
                    case 'robust'
                        if any(l_nz)
                            d_mean = wmean(di(l_nz),1/sum(l_nz),method,rescale);
                        else
                            d_mean = difftensor;
                        end
                    otherwise
                        error('difftensor:mean', ...
                            '[difftensor] Wrong options: ''classic'' or ''robust''.');
                end
                
            else
                d_mean(1,sz(2)) = difftensor;
                for ii=1:sz(2)
                    d_mean(ii) = mean(di(:,ii),method,rescale,opt);
                end
            end
        end
        
        function s = std(di,method,rescale)
            % s = std(di,method,rescale)
            %
            % Estimate the standard deviation (std) of an array of tensors
            % around its mean.
            % Should have about the same behviour as the 'std' operator on
            % an array of scalar, i.e. column wise std.
            
            if nargin<3, rescale = 'kappa'; end
            if nargin<2, method = 'SQ'; end
            sz = size(di);
            if length(sz)>2
                error('difftensor:std', ...
                    '[difftensor] Arrays must be 2D at most.');
            elseif all(sz<3)
                % no std possible
                s = [];
            elseif any(sz==1)
                % std of all element, row or column.
                % s = st_dev(di,method);
                dm = mean(di,method,rescale);
                D = dist(dm,di,method);
                s = sqrt(sum(D.^2))/(prod(sz)-1);
            else
                s = zeros(1,sz(2));
                for ii=1:sz(2)
                    % s(ii) = st_dev(di(:,ii),method);
                    dm = mean(di(:,ii),method);
                    D = dist(dm,di(:,ii),method);
                    s(ii) = sqrt(sum(D.^2))/(sz(1)-1);
                end
            end
        end
        
    end
    
end

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% SUBFUNCTIONS : Utility functions
%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function q = mat2quat(V)
% Turning the eigenvectors into a quaternion
tr = trace(V);
r = sqrt(1+V(1,1)-V(2,2)-V(3,3));

if abs(tr+1)<1e-6 && r~=0
    q = mat2quat_2(V);
else
    theta = real(acos((tr-1)/2));
    if mod(theta,2*pi)~=0
        w = [V(3,2)-V(2,3) ; V(1,3)-V(3,1) ; V(2,1)-V(1,2)] ...
            / (2*sin(theta)) ;
    else
        w = zeros(3,1);
    end
    a = cos(theta/2);
    V = w*sin(theta/2);
    
    q = [a ; V];
    q = q/norm(q);
end
end

function q = mat2quat_2(V)
% Other way of turning the eigenvectors into a quaternion
r = sqrt(1+V(1,1)-V(2,2)-V(3,3));
% if r==0
%   q = mat2quat(V);
% else
q = zeros(4,1);
q(1) = (V(3,2)-V(2,3))/(2*r);
q(2) = r/2;
q(3) = (V(1,2)+V(2,1))/(2*r);
q(4) = (V(3,1)+V(1,3))/(2*r);
end

function q2n = realignQ(q1,Q2)
% Realigning quaternion_2 (single q or set of 8 orients) on quaternion_1
if size(Q2,2)==1
    Q2 = getSetQ(Q2);
end
a = q1'*Q2;
[~,I_N] = max(a);
q2n = Q2(:,I_N);
end

function qm = multiplication(q1,q2)
% Multiplying 2 quaternions
qm = zeros(4,1);
qm(1) = q1'*[q2(1); -q2(2); -q2(3); -q2(4)];
qm(2) = q1(1)*q2(2)+ q2(1)*q1(2)+ q1(3)*q2(4)-q1(4)*q2(3);
qm(3) = q1(1)*q2(3)+ q2(1)*q1(3)+ q1(4)*q2(2)-q1(2)*q2(4);
qm(4) = q1(1)*q2(4)+q2(1)*q1(4)+ q1(2)*q2(3)-q1(3)*q2(2);
end

function R = quat2mat(q)
% Turning a quaternion into a rotation matrix/eigenvectors
a = q(1);
V = q(2:4);
theta = 2*acos(a);

if theta==0
    w = [0 0 0];
else
    w = V/sin(theta/2);
end

w_hat = [0 -w(3) w(2); w(3) 0 -w(1); -w(2) w(1) 0];
R = expm(w_hat*theta);
% R = Rexpm(w_hat*theta);
end
% 
% function dr = rot_q(d,qR)
% % Rotate d by qR (quaternion).
% % R is a single unit quaternion -> apply on all elements of d     
% dr = d;
% QR = [qR -qR];
% for ii=1:numel(d)
%     qR_R = realignQ(d(ii).Orientation,QR);
%     qnew = multiplication(qR_R,d(ii).Orientation);
%     dr(ii).Orientation = qnew;
%     dr(ii).EigVectors = quat2mat(qnew);
% end
% end

function di = realignD(q1,Q2)
% Distance between set of quaternions.
a  = q1'*Q2;
di = max(a);
di = 2-2*di;
end

function Q = getSetQ(q)
% Get 8 permutations of quaternion
Q = [q(1) -q(1)   q(2) -q(2)   q(3) -q(3)  q(4) -q(4) ;
     q(2) -q(2)  -q(1)  q(1)   q(4) -q(4) -q(3)  q(3) ;
     q(3) -q(3)  -q(4)  q(4)  -q(1)  q(1)  q(2) -q(2) ;
     q(4) -q(4)   q(3) -q(3)  -q(2)  q(2) -q(1)  q(1) ];
end

function RA = calcRA(v)
% Calculate RA
lambdam = sum(v)/3;
RA = sqrt(sum((v-lambdam*ones(3,1)).^2)) / lambdam / sqrt(6);
end

function FA = calcFA(v)
% Calculate FA
lambdam = sum(v)/3;
FA = sqrt(3/2) * sqrt(sum( (v-lambdam).^2 )) / sqrt(sum(v.^2));
end

function HA = calcHA(v)
% Calculate HA
v = sort(v,'descend'); % Check the ordering of the eigenvalues
HA = log(v(1)/v(3));
end

function dLE = dist_LE(d1,d2)
% calculate Log-Euclidian distance between 2 tensors
R1 = d1.EigVectors;
if isempty(R1)
    v = d1.Orientation;
    R1 = quat2mat(v);
end
R2 = d2.EigVectors;
if isempty(R2)
    v = d2.Orientation;
    R2 = quat2mat(v);
end
L1 = R1*diag(log(d1.EigValues))*R1';
L2 = R2*diag(log(d2.EigValues))*R2';
A  = L1 - L2;
dLE = sqrt(trace(A'*A));
end

function SdQ = dist_SQ(d1,d2)
% calculate SQ distance between 2 tensors

% distance according to eigenvalues
L1 = log(d1.EigValues);
L2 = log(d2.EigValues);
dist_v = sum((L2-L1).^2);
% distance accroding to orientation, depending on k
% k = calck(getHA(d1),getHA(d2));
k = calck(d1.HA,d2.HA);
if k<1e-4
    % no angular information
    SdQ = sqrt(dist_v);
else
    % with angular information
    d2.setQ = getSetQ(d2.Orientation);
    dist_Q = realignD(d1.Orientation,d2.setQ);
    if dist_Q <1e-4
        dist_Q = 0;
    end
    SdQ = k*sqrt(dist_Q) + sqrt(dist_v);
end
end

function k = calck(HA1,HA2)
% weighting of eigenvector distance
d1= size(HA1);
d2= size(HA2);
alpha = 0.6;
if prod(d1)~= prod(d2) && prod(d2) == 1
    k = zeros(prod(d1),1);
    for ii=1 : prod(d1)
        xB = alpha*min(HA1(ii),HA2);
        k(ii) = xB^4/(1+xB^4);
    end
elseif prod(d1)==prod(d2)
    k = zeros(prod(d1),1);
    for ii=1 : prod(d1)
        xB = alpha*min(HA1(ii),HA2(ii));
        k(ii) = xB^4/(1+xB^4);
    end
else
    error('difftensor:calck', ...
        '[difftensor] Problem of dimension to compute k');
end
end

function S = Sexpm(L)
% matrix exponential
[v,d] = eig(L);
S = v*diag(exp(diag(d)))*v';
end

